

# ABS - Absolute value of ACC
#-----------------------------
# 1011 1110 0000 0000 -  
:ABS  is  op_0_15=0b1011111000000000  {
}

# ADD - Add to ACC
#------------------
# 0010 SHFT IAAA AAAA -  shift 0 to 15, direct or indirect
:ADD ind is  op_12_15=0b0010 & shft_8_11=0 & is_arx=0 & is_ind=1 & ind  {
  instr_add(*ind);
}
:ADD ind, shft_8_11, arx_0_2 is op_12_15=0b0010 & is_arx=1 & is_ind=1 & ind & shft_8_11 & arx_0_2  {
  instr_add_shift(*ind, shft_8_11);
}
:ADD ind, shft_8_11 is  op_12_15=0b0010 & is_arx=0 & is_ind=1 & ind & shft_8_11  {
  instr_add_shift(*ind, shft_8_11);
}
:ADD dma is  op_12_15=0b0010 & shft_8_11=0 & is_ind=0 & dma  {
  instr_add(*dma);
}
:ADD dma, shft_8_11 is  op_12_15=0b0010 & is_ind=0 & dma & shft_8_11  {
  instr_add_shift(*dma, shft_8_11);
}
# 1011 1111 1001 SHFT -  shift 0 to 15, long immediate
:ADD #long_imm is  op_4_15=0b101111111001 & shft_0_3=0 ; long_imm {
  instr_add(long_imm);
}
:ADD #long_imm, shft_0_3 is  op_4_15=0b101111111001 & shft_0_3 ; long_imm {
  instr_add_shift(long_imm, shft_0_3);
}
# 0110 0001 IAAA AAAA -  shift of 16, direct or indirect
:ADD ind, "16", arx_0_2 is  op_8_15=0b01100001 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_add_shift(*ind, 16);
}
:ADD ind, "16" is  op_8_15=0b01100001 & is_arx=0 & is_ind=1 & ind  {
  instr_add_shift(*ind, 16);
}
:ADD dma, "16" is  op_8_15=0b01100001 & is_ind=0 & dma  {
  instr_add_shift(*dma, 16);
}
# 1011 1000 IIII IIII -  short immediate
:ADD #short_imm_0_7 is  op_8_15=0b10111000 & short_imm_0_7  {
  instr_add(short_imm_0_7);
}

# ADDC - Add to ACC with carry
#------------------------------
# 0110 0000 IAAA AAAA -  direct or indirect
:ADDC ind, arx_0_2 is  op_8_15=0b01100000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_addc(*ind);
}
:ADDC ind is  op_8_15=0b01100000 & is_arx=0 & is_ind=1 & ind  {
  instr_addc(*ind);
}
:ADDC dma is  op_8_15=0b01100000 & is_ind=0 & dma  {
  instr_addc(*dma);
}

# ADDS - Add to low ACC with sign-extension suppressed
#------------------------------------------------------
# 0110 0010 IAAA AAAA -  direct or indirect
:ADDS ind, arx_0_2 is  op_8_15=0b01100010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_adds(*ind);
}
:ADDS ind is  op_8_15=0b01100010 & is_arx=0 & is_ind=1 & ind  {
  instr_adds(*ind);
}
:ADDS dma is  op_8_15=0b01100010 & is_ind=0 & dma  {
  instr_adds(*dma);
}

# ADDT - Add to ACC with shift (0 to 15) specified by TREG
#----------------------------------------------------------
# 0110 0011 IAAA AAAA -  direct or indirect
:ADDT ind, arx_0_2 is  op_8_15=0b01100011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_addt(*ind);
}
:ADDT ind is  op_8_15=0b01100011 & is_arx=0 & is_ind=1 & ind  {
  instr_addt(*ind);
}
:ADDT dma is  op_8_15=0b01100011 & is_ind=0 & dma  {
  instr_addt(*dma);
}

# ADRK - Add constant to current AR
#-----------------------------------
# 0111 1000 IIII IIII -  short immediate
:ADRK #short_imm_0_7 is  op_8_15=0b01111000 & short_imm_0_7  {

}

# AND - AND ACC
#---------------
# 0110 1110 IAAA AAAA -  with data value, direct or indirect
:AND ind, arx_0_2 is  op_8_15=0b01101110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_and(*ind);
}
:AND ind is  op_8_15=0b01101110 & is_arx=0 & is_ind=1 & ind  {
  instr_and(*ind);
}
:AND dma is  op_8_15=0b01101110 & is_ind=0 & dma  {
  instr_and(*dma);
}
# 1011 1111 1011 SHFT -  with shift 0 to 15, long immediate
:AND #long_imm is  op_4_15=0b101111111011 & shft_0_3=0 ; long_imm {
  instr_and(long_imm);
}
:AND #long_imm, shft_0_3 is  op_4_15=0b101111111011 & shft_0_3 ; long_imm {
  instr_and_shift(long_imm, shft_0_3);
}
# 1011 1110 1000 0001 -  with shift of 16, long immediate
:AND #long_imm, "16" is  op_0_15=0b1011111010000001 ; long_imm {
  instr_and_shift(long_imm, 16);
}

# APAC - Add PREG to ACC
#------------------------
# 1011 1110 0000 0100 -  
:APAC  is  op_0_15=0b1011111000000100  {
  ACC = ACC + PREG;
}

# B - Branch unconditionally
#----------------------------
# 0111 1001 1AAA AAAA -  indirect
:B pma, ind, arx_0_2 is  op_7_15=0b011110011 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {
  goto pma;
  update_arx(arx_0_2);
}
:B pma, ind is  op_7_15=0b011110011 & is_arx=0 & is_ind=1 & ind ; pma {
  goto pma;
}

# BACC - Branch to address specified by ACC
#-------------------------------------------
# 1011 1110 0010 0000 -  
:BACC  is op_0_15=0b1011111000100000  {
  local target:2 = ACC[0,16];
  goto [target];
}

# BANZ - Branch on current AR not 0
#-----------------------------------
# 0111 1011 1AAA AAAA -  indirect
:BANZ pma, ind, arx_0_2 is  op_7_15=0b011110111 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {
    if $(TC) goto pma;
}
:BANZ pma, ind is  op_7_15=0b011110111 & is_arx=0 & is_ind=1 & ind ; pma {
    if $(TC) goto pma;
}

# BCND - Branch conditionally
#-----------------------------
# 1110 00TP ZLVC ZLVC -  
:BCND pma, tpzlvczlvc_0_9 is  op_10_15=0b111000 & tpzlvczlvc_0_9 ; pma {
  if $(TC) goto pma;
}

# BIT - Test bit
#----------------
# 0100 BITX IAAA AAAA -  direct or indirect
:BIT ind, bitx_8_11, arx_0_2 is  op_12_15=0b0100 & is_arx=1 & is_ind=1 & ind & bitx_8_11 & arx_0_2  {
  instr_bit(*ind, bitx_8_11);
}
:BIT ind, bitx_8_11 is  op_12_15=0b0100 & is_arx=0 & is_ind=1 & ind & bitx_8_11  {
  instr_bit(*ind, bitx_8_11);
}
:BIT dma, bitx_8_11 is  op_12_15=0b0100 & is_ind=0 & dma & bitx_8_11  {
  instr_bit(*dma, bitx_8_11);
}

# BITT - Test bit specified by TREG
#-----------------------------------
# 0110 1111 IAAA AAAA -  direct or indirect
:BITT ind, arx_0_2 is  op_8_15=0b01101111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_bitt(*ind);
}
:BITT ind is  op_8_15=0b01101111 & is_arx=0 & is_ind=1 & ind  {
  instr_bitt(*ind);
}
:BITT dma is  op_8_15=0b01101111 & is_ind=0 & dma  {
  instr_bitt(*dma);
}

# BLDD - Block move from data memory to data memory
#---------------------------------------------------
# 1010 1000 IAAA AAAA -  direct/indirect with long immediate source
:BLDD #long_imm, ind, arx_0_2 is  op_8_15=0b10101000 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {}
:BLDD #long_imm, ind is  op_8_15=0b10101000 & is_arx=0 & is_ind=1 & ind ; long_imm {}
:BLDD #long_imm, dma is  op_8_15=0b10101000 & is_ind=0 & dma ; long_imm {}
# 1010 1001 IAAA AAAA -  direct/indirect with long immediate destination
:BLDD #long_imm, ind, arx_0_2 is  op_8_15=0b10101001 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {}
:BLDD #long_imm, ind is  op_8_15=0b10101001 & is_arx=0 & is_ind=1 & ind ; long_imm {}
:BLDD #long_imm, dma is  op_8_15=0b10101001 & is_ind=0 & dma ; long_imm {}

# BLPD - Block move from program memory to data memory
#------------------------------------------------------
# 1010 0101 IAAA AAAA -  direct/indirect with long immediate source
:BLPD pma, ind, arx_0_2 is  op_8_15=0b10100101 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {}
:BLPD pma, ind is  op_8_15=0b10100101 & is_arx=0 & is_ind=1 & ind ; pma {}
:BLPD pma, dma is  op_8_15=0b10100101 & is_ind=0 & dma ; pma {}

# CALA - Call subroutine at location specified by ACC
#-----------------------------------------------------
# 1011 1110 0011 0000 -  
:CALA  is  op_0_15=0b1011111000110000  {
  push(&:1 inst_next);
  call [ACC];
}

# CALL - Call subroutine
#------------------------
# 0111 1010 1AAA AAAA -  indirect
:CALL pma, ind, arx_0_2 is  op_7_15=0b011110101 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {
  push(&:1 inst_next);
  call pma;
}
:CALL pma, ind is  op_7_15=0b011110101 & is_arx=0 & is_ind=1 & ind ; pma {
  push(&:1 inst_next);
  call pma;
}

# CC - Call conditionally
#-------------------------
# 1110 10TP ZLVC ZLVC -  
:CC pma, tpzlvczlvc_0_9 is  op_10_15=0b111010 & tpzlvczlvc_0_9 ; pma {
    call pma;
}

# CLRC - Clear control bits
#---------------------------
# 1011 1110 0100 1110 -  Clear C bit
:CLRC^" C" is  op_0_15=0b1011111001001110  {
  $(C) = 0;
}
# 1011 1110 0100 0100 -  Clear CNF bit
:CLRC^" CNF" is  op_0_15=0b1011111001000100  {
  $(CNF) = 0;
}
# 1011 1110 0100 0000 -  Clear INTM bit
:CLRC^" INTM" is  op_0_15=0b1011111001000000  {
  $(INTM) = 0;
}
# 1011 1110 0100 0010 -  Clear OVM bit
:CLRC^" OVM" is  op_0_15=0b1011111001000010  {
  $(OVM) = 0;
}
# 1011 1110 0100 0110 -  Clear SXM bit
:CLRC^" SXM" is  op_0_15=0b1011111001000110  {
  $(SXM) = 0;
}
# 1011 1110 0100 1010 -  Clear TC bit
:CLRC^" TC" is  op_0_15=0b1011111001001010  {
  $(TC) = 0;
}
# 1011 1110 0100 1100 -  Clear XF bit
:CLRC^" XF" is  op_0_15=0b1011111001001100  {
  $(XF) = 0;
}

# CMPL - Complement ACC
#-----------------------
# 1011 1110 0000 0001 -  
:CMPL  is  op_0_15=0b1011111000000001  {
  ACC = ~ACC;
}

# CMPR - Compare current AR with AR0
#------------------------------------
# 1011 1111 0100 01CM -  
:CMPR cm_0_1 is  op_2_15=0b10111111010001 & cm_0_1  {}

# DMOV - Data move in data memory
#---------------------------------
# 0111 0111 IAAA AAAA -  direct or indirect
:DMOV ind, arx_0_2 is  op_8_15=0b01110111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:DMOV ind is  op_8_15=0b01110111 & is_arx=0 & is_ind=1 & ind  {}
:DMOV dma is  op_8_15=0b01110111 & is_ind=0 & dma  {}

# IDLE - Idle until interrupt
#-----------------------------
# 1011 1110 0010 0010 -  
:IDLE  is  op_0_15=0b1011111000100010  {
}

# IN - Input data from I/O location
#-----------------------------------
# 1010 1111 IAAA AAAA -  direct or indirect
:IN #long_imm, ind, arx_0_2 is  op_8_15=0b10101111 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {}
:IN #long_imm, ind is  op_8_15=0b10101111 & is_arx=0 & is_ind=1 & ind ; long_imm {}
:IN #long_imm, dma is  op_8_15=0b10101111 & is_ind=0 & dma ; long_imm {}

# INTR - Soft interrupt
#-----------------------
# 1011 1110 0111 NTR# -  
:INTR ntr_0_3 is  op_4_15=0b101111100111 & ntr_0_3  {}

# LACC - Load ACC
#-----------------
# 0001 SHFT IAAA AAAA -  shift 0 to 15, direct or indirect
:LACC ind is  op_12_15=0b0001 & shft_8_11=0 & is_arx=0 & is_ind=1 & ind  {
  instr_lacc(*ind);
}
:LACC ind, shft_8_11, arx_0_2 is  op_12_15=0b0001 & is_arx=1 & is_ind=1 & ind & shft_8_11 & arx_0_2  {
  instr_lacc_shift(*ind, shft_8_11);
}
:LACC ind, shft_8_11 is  op_12_15=0b0001 & is_arx=0 & is_ind=1 & ind & shft_8_11  {
  instr_lacc_shift(*ind, shft_8_11);
}
:LACC dma is  op_12_15=0b0001 & shft_8_11=0 & is_ind=0 & dma  {
  instr_lacc(*dma);
}
:LACC dma, shft_8_11 is  op_12_15=0b0001 & is_ind=0 & dma & shft_8_11  {
  instr_lacc_shift(*dma, shft_8_11);
}
# 1011 1111 1000 SHFT -  shift 0 to 15, long immediate
:LACC #long_imm is  op_4_15=0b101111111000 & shft_0_3=0 ; long_imm {
  instr_lacc(long_imm);
}
:LACC #long_imm, shft_0_3 is  op_4_15=0b101111111000 & shft_0_3 ; long_imm {
  instr_lacc_shift(long_imm, shft_0_3);
}
# 0110 1010 IAAA AAAA -  shift of 16, direct or indirect
:LACC ind, "16", arx_0_2 is  op_8_15=0b01101010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_lacc_shift(*ind, 16);
}
:LACC ind, "16" is  op_8_15=0b01101010 & is_arx=0 & is_ind=1 & ind  {
  instr_lacc_shift(*ind, 16);
}
:LACC dma, "16" is  op_8_15=0b01101010 & is_ind=0 & dma  {
  instr_lacc_shift(*dma, 16);
}

# LACL - Load low word of ACC
#-----------------------------
# 0110 1001 IAAA AAAA -  direct or indirect
:LACL ind, arx_0_2 is  op_8_15=0b01101001 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_lacl(*ind);
}
:LACL ind is  op_8_15=0b01101001 & is_arx=0 & is_ind=1 & ind  {
  instr_lacl(*ind);
}
:LACL dma is  op_8_15=0b01101001 & is_ind=0 & dma  {
  instr_lacl(*dma);
}
# 1011 1001 IIII IIII -  short immediate
:LACL #short_imm_0_7 is op_8_15=0b10111001 & short_imm_0_7 {
  instr_lacl(short_imm_0_7);
}

# LACT - Load ACC with shift (0 to 15) specified by TREG
#--------------------------------------------------------
# 0110 1011 IAAA AAAA -  direct or indirect
:LACT ind, arx_0_2 is  op_8_15=0b01101011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_lact(*ind);
}
:LACT ind is  op_8_15=0b01101011 & is_arx=0 & is_ind=1 & ind  {
  instr_lact(*ind);
}
:LACT dma is  op_8_15=0b01101011 & is_ind=0 & dma  {
  instr_lact(*dma);
}

# LAR - Load specified AR
#-------------------------
# 0000 0ARX IAAA AAAA -  from specified data location, direct or indirect
:LAR arx2_8_10, ind, arx_0_2 is  op_11_15=0b00000 & is_arx=1 & is_ind=1 & arx2_8_10 & ind & arx_0_2  {
  instr_lar(arx2_8_10, *ind);
}
:LAR arx2_8_10, ind is  op_11_15=0b00000 & is_arx=0 & is_ind=1 & arx2_8_10 & ind  {
  instr_lar(arx2_8_10, *ind);
}
:LAR arx2_8_10, dma is  op_11_15=0b00000 & is_ind=0 & arx2_8_10 & dma  {
  instr_lar(arx2_8_10, *dma);
}
# 1011 0ARX IIII IIII -  with constant, short immediate
:LAR arx2_8_10, #short_imm_0_7 is  op_11_15=0b10110 & arx2_8_10 & short_imm_0_7  {
  instr_lar(arx2_8_10, short_imm_0_7);
}
# 1011 1111 0000 1ARX -  with constant, long immediate
:LAR #long_imm, arx2_0_2 is  op_3_15=0b1011111100001 & arx2_0_2 ; long_imm {
  instr_lar(arx2_0_2, long_imm);
}

# LDP - Load data page pointer
#------------------------------
# 0000 1101 IAAA AAAA -  direct or indirect
:LDP ind, arx_0_2 is  op_8_15=0b00001101 & is_arx=1 & is_ind=1 & ind & arx_0_2 {
  instr_ldp(*ind);
}
:LDP ind is  op_8_15=0b00001101 & is_arx=0 & is_ind=1 & ind  {
  instr_ldp(*ind);
}
:LDP dma is  op_8_15=0b00001101 & is_ind=0 & dma  {
  instr_ldp(*dma);
}
# 1011 110I IIII IIII -  short immediate
:LDP addr9_0_8 is  op_9_15=0b1011110 & addr9_0_8  [
  ctx_dp = addr9_0_8; 
  globalset(inst_next, ctx_dp); 
] {
  instr_ldp(addr9_0_8);
}

# LPH - Load high PREG
#----------------------
# 0111 0101 IAAA AAAA -  direct or indirect
:LPH ind, arx_0_2 is  op_8_15=0b01110101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_lph(*ind);
}
:LPH ind is  op_8_15=0b01110101 & is_arx=0 & is_ind=1 & ind  {
  instr_lph(*ind);
}
:LPH dma is  op_8_15=0b01110101 & is_ind=0 & dma  {
  instr_lph(*dma);
}

# LST - Load status register
#----------------------------
# 0000 1110 IAAA AAAA -  ST0, direct or indirect
:LST #0, ind, arx_0_2 is  op_8_15=0b00001110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_lst0(*ind);
}
:LST #0, ind is  op_8_15=0b00001110 & is_arx=0 & is_ind=1 & ind  {
  instr_lst0(*ind);
}
:LST #0, dma is  op_8_15=0b00001110 & is_ind=0 & dma  {
  instr_lst0(*dma);
}
# 0000 1111 IAAA AAAA -  ST1, direct or indirect
:LST #1, ind, arx_0_2 is  op_8_15=0b00001111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_lst1(*ind);
}
:LST #1, ind is  op_8_15=0b00001111 & is_arx=0 & is_ind=1 & ind  {
  instr_lst1(*ind);
}
:LST #1, dma is  op_8_15=0b00001111 & is_ind=0 & dma  {
  instr_lst1(*dma);
}

# LT - Load TREG
#----------------
# 0111 0011 IAAA AAAA -  direct or indirect
:LT ind, arx_0_2 is  op_8_15=0b01110011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_lt(*ind);
}
:LT ind is  op_8_15=0b01110011 & is_arx=0 & is_ind=1 & ind  {
  instr_lt(*ind);
}
:LT dma is  op_8_15=0b01110011 & is_ind=0 & dma  {
  instr_lt(*dma);
}

# LTA - Load TREG and accumulate previous product
#-------------------------------------------------
# 0111 0000 IAAA AAAA -  direct or indirect
:LTA ind, arx_0_2 is  op_8_15=0b01110000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LTA ind is  op_8_15=0b01110000 & is_arx=0 & is_ind=1 & ind  {}
:LTA dma is  op_8_15=0b01110000 & is_ind=0 & dma  {}

# LTD - Load TREG, accumulate previous product, and move data
#-------------------------------------------------------------
# 0111 0010 IAAA AAAA -  direct or indirect
:LTD ind, arx_0_2 is  op_8_15=0b01110010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LTD ind is  op_8_15=0b01110010 & is_arx=0 & is_ind=1 & ind  {}
:LTD dma is  op_8_15=0b01110010 & is_ind=0 & dma  {}

# LTP - Load TREG and store PREG in accumulator
#-----------------------------------------------
# 0111 0001 IAAA AAAA -  direct or indirect
:LTP ind, arx_0_2 is  op_8_15=0b01110001 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LTP ind is  op_8_15=0b01110001 & is_arx=0 & is_ind=1 & ind  {}
:LTP dma is  op_8_15=0b01110001 & is_ind=0 & dma  {}

# LTS - Load TREG and subtract previous product
#-----------------------------------------------
# 0111 0100 IAAA AAAA -  direct or indirect
:LTS ind, arx_0_2 is  op_8_15=0b01110100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LTS ind is  op_8_15=0b01110100 & is_arx=0 & is_ind=1 & ind  {}
:LTS dma is  op_8_15=0b01110100 & is_ind=0 & dma  {}

# MAC - Multiply and accumulate
#-------------------------------
# 1010 0010 IAAA AAAA -  direct or indirect
:MAC pma, ind, arx_0_2 is  op_8_15=0b10100010 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {}
:MAC pma, ind is  op_8_15=0b10100010 & is_arx=0 & is_ind=1 & ind ; pma {}
:MAC pma, dma is  op_8_15=0b10100010 & is_ind=0 & dma ; pma {}

# MACD - Multiply and accumulate with data move
#-----------------------------------------------
# 1010 0011 IAAA AAAA -  direct or indirect
:MACD pma, ind, arx_0_2 is  op_8_15=0b10100011 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {}
:MACD pma, ind is  op_8_15=0b10100011 & is_arx=0 & is_ind=1 & ind ; pma {}
:MACD pma, dma is  op_8_15=0b10100011 & is_ind=0 & dma ; pma {}

# MAR - Modify current AR and/or ARP
#------------------------------------
# 1000 1011 IAAA AAAA -  indirect (performs no operation when direct)
:MAR ind, arx_0_2 is  op_8_15=0b10001011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MAR ind is  op_8_15=0b10001011 & is_arx=0 & is_ind=1 & ind  {}
:MAR dma is  op_8_15=0b10001011 & is_ind=0 & dma  {}

# MPY - Multiply TREG
#---------------------
# 0101 0100 IAAA AAAA -  by data value, direct or indirect
:MPY ind, arx_0_2 is  op_8_15=0b01010100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MPY ind is  op_8_15=0b01010100 & is_arx=0 & is_ind=1 & ind  {}
:MPY dma is  op_8_15=0b01010100 & is_ind=0 & dma  {}
# 110I IIII IIII IIII -  by 13-bit constant, short immediate
:MPY addr13_0_12 is  op_13_15=0b110 & addr13_0_12  {}

# MPYA - Multiply and accumulate previous product
#-------------------------------------------------
# 0101 0000 IAAA AAAA -  direct or indirect
:MPYA ind, arx_0_2 is  op_8_15=0b01010000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MPYA ind is  op_8_15=0b01010000 & is_arx=0 & is_ind=1 & ind  {}
:MPYA dma is  op_8_15=0b01010000 & is_ind=0 & dma  {}

# MPYS - Multiply and subtract previous product
#-----------------------------------------------
# 0101 0001 IAAA AAAA -  direct or indirect
:MPYS ind, arx_0_2 is  op_8_15=0b01010001 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MPYS ind is  op_8_15=0b01010001 & is_arx=0 & is_ind=1 & ind  {}
:MPYS dma is  op_8_15=0b01010001 & is_ind=0 & dma  {}

# MPYU - Multiply unsigned
#--------------------------
# 0101 0101 IAAA AAAA -  direct or indirect
:MPYU ind, arx_0_2 is  op_8_15=0b01010101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MPYU ind is  op_8_15=0b01010101 & is_arx=0 & is_ind=1 & ind  {}
:MPYU dma is  op_8_15=0b01010101 & is_ind=0 & dma  {}

# NEG - Negate ACC
#------------------
# 1011 1110 0000 0010 -  
:NEG  is  op_0_15=0b1011111000000010  {
  ACC = -ACC;
}

# NMI - Nonmaskable interrupt
#-----------------------------
# 1011 1110 0101 0010 -  
:NMI  is  op_0_15=0b1011111001010010  {}

# NOP - No operation
#--------------------
# 1000 1011 0000 0000 -  
:NOP  is  op_0_15=0b1000101100000000  {}

# NORM - Normalize the contents of ACC
#--------------------------------------
# 1010 0000 IAAA AAAA -  indirect
:NORM ind, arx_0_2 is  op_8_15=0b10100000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:NORM ind is  op_8_15=0b10100000 & is_arx=0 & is_ind=1 & ind  {}
:NORM dma is  op_8_15=0b10100000 & is_ind=0 & dma  {}

# OR - OR ACC
#-------------
# 0110 1101 IAAA AAAA -  with data value, direct or indirect
:OR ind, arx_0_2 is  op_8_15=0b01101101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_or(*ind);
}
:OR ind is  op_8_15=0b01101101 & is_arx=0 & is_ind=1 & ind  {
  instr_or(*ind);
}
:OR dma is  op_8_15=0b01101101 & is_ind=0 & dma  {
  instr_or(*dma);
}
# 1011 1111 1100 SHFT -  with shift 0 to 15, long immediate
:OR #long_imm is  op_4_15=0b101111111100 & shft_0_3=0 ; long_imm {
  instr_or(long_imm);
}
:OR #long_imm, shft_0_3 is  op_4_15=0b101111111100 & shft_0_3 ; long_imm {
  instr_or_shift(long_imm, shft_0_3);
}
# 1011 1110 1000 0010 -  with shift of 16, long immediate
:OR #long_imm, "16" is  op_0_15=0b1011111010000010 ; long_imm {
  instr_or_shift(long_imm, 16);
}

# OUT - Output data to port
#---------------------------
# 0000 1100 IAAA AAAA -  direct or indirect
:OUT #long_imm, ind, arx_0_2 is  op_8_15=0b00001100 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {}
:OUT #long_imm, ind is  op_8_15=0b00001100 & is_arx=0 & is_ind=1 & ind ; long_imm {}
:OUT #long_imm, dma is  op_8_15=0b00001100 & is_ind=0 & dma ; long_imm {}

# PAC - Load ACC with PREG
#--------------------------
# 1011 1110 0000 0011 -  
:PAC  is  op_0_15=0b1011111000000011  {
  ACC = PREG;
}

# POP - Pop top of stack to low ACC
#-----------------------------------
# 1011 1110 0011 0010 -  
:POP  is  op_0_15=0b1011111000110010  {
  local val:2 = 0;
  pop(val);
  ACC[0,16] = val;
}

# POPD - Pop top of stack to data memory
#----------------------------------------
# 1000 1010 IAAA AAAA -  direct or indirect
:POPD ind, arx_0_2 is  op_8_15=0b10001010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_popd(ind);
}
:POPD ind is  op_8_15=0b10001010 & is_arx=0 & is_ind=1 & ind  {
  instr_popd(ind);
}
:POPD dma is  op_8_15=0b10001010 & is_ind=0 & dma  {
  instr_popd(dma);
}

# PSHD - Push data memory value on stack
#----------------------------------------
# 0111 0110 IAAA AAAA -  direct or indirect
:PSHD ind, arx_0_2 is  op_8_15=0b01110110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_pshd(*ind);
}
:PSHD ind is  op_8_15=0b01110110 & is_arx=0 & is_ind=1 & ind  {
  instr_pshd(*ind);
}
:PSHD dma is  op_8_15=0b01110110 & is_ind=0 & dma  {
  instr_pshd(*dma);
}

# PUSH - Push low ACC onto stack
#--------------------------------
# 1011 1110 0011 1100 -  
:PUSH  is  op_0_15=0b1011111000111100  {
  push(ACC[0,16]);
}

# RET - Return from subroutine
#------------------------------
# 1110 1111 0000 0000 -  
:RET  is  op_0_15=0b1110111100000000  {
  retAddr:2 = 0;
  pop(retAddr);
	return [retAddr];
}

# RETC - Return conditionally
#-----------------------------
# 1110 11TP ZLVC ZLVC -  
:RETC tpzlvczlvc_0_9 is  op_10_15=0b111011 & tpzlvczlvc_0_9  {
  retAddr:2 = 0;
  pop(retAddr);
  return [retAddr];
}

# ROL - Rotate ACC left
#-----------------------
# 1011 1110 0000 1100 -  
:ROL  is  op_0_15=0b1011111000001100  {}

# ROR - Rotate ACC right
#------------------------
# 1011 1110 0000 1101 -  
:ROR  is  op_0_15=0b1011111000001101  {}

# RPT - Repeat next instruction
#-------------------------------
# 0000 1011 IAAA AAAA -  direct or indirect
:RPT ind, arx_0_2 is  op_8_15=0b00001011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:RPT ind is  op_8_15=0b00001011 & is_arx=0 & is_ind=1 & ind  {}
:RPT dma is  op_8_15=0b00001011 & is_ind=0 & dma  {}
# 1011 1011 IIII IIII -  short immediate
:RPT #short_imm_0_7 is  op_8_15=0b10111011 & short_imm_0_7  {}

# SACH - Store high ACC
#-----------------------
# 1001 1SHF IAAA AAAA -  shift 0 to 7, direct or indirect
:SACH ind is  op_11_15=0b10011 & shf_8_10=0 & is_arx=0 & is_ind=1 & ind  {
  instr_sach(ind, 0);
}
:SACH ind, shf_8_10, arx_0_2 is  op_11_15=0b10011 & is_arx=1 & is_ind=1 & ind & shf_8_10 & arx_0_2  {
  instr_sach(ind, shf_8_10);
}
:SACH ind, shf_8_10 is  op_11_15=0b10011 & is_arx=0 & is_ind=1 & ind & shf_8_10  {
  instr_sach(ind, shf_8_10);
}
:SACH dma is  op_11_15=0b10011 & shf_8_10=0 & is_ind=0 & dma  {
  instr_sach(dma, 0);
}
:SACH dma, shf_8_10 is  op_11_15=0b10011 & is_ind=0 & dma & shf_8_10  {
  instr_sach(dma, shf_8_10);
}

# SACL - Store low ACC
#----------------------
# 1001 0SHF IAAA AAAA -  shift 0 to 7, direct or indirect
:SACL ind is  op_11_15=0b10010 & shf_8_10=0 & is_arx=0 & is_ind=1 & ind  {
  instr_sacl(ind, 0);
}
:SACL ind, shf_8_10, arx_0_2 is  op_11_15=0b10010 & is_arx=1 & is_ind=1 & ind & shf_8_10 & arx_0_2  {
  instr_sacl(ind, shf_8_10);
}
:SACL ind, shf_8_10 is  op_11_15=0b10010 & is_arx=0 & is_ind=1 & ind & shf_8_10  {
  instr_sacl(ind, shf_8_10);
}
:SACL dma is  op_11_15=0b10010 & shf_8_10=0 & is_ind=0 & dma  {
  instr_sacl(dma, 0);
}
:SACL dma, shf_8_10 is  op_11_15=0b10010 & is_ind=0 & dma & shf_8_10  {
  instr_sacl(dma, shf_8_10);
}

# SAR - Store specified AR
#--------------------------
# 1000 0ARX IAAA AAAA -  to specified data location, direct or indirect
:SAR arx2_8_10, ind, arx_0_2 is  op_11_15=0b10000 & is_arx=1 & is_ind=1 & arx2_8_10 & ind & arx_0_2  {
  ind = arx2_8_10;
}
:SAR arx2_8_10, ind is  op_11_15=0b10000 & is_arx=0 & is_ind=1 & arx2_8_10 & ind  {
  ind = arx2_8_10;
}
:SAR arx2_8_10, dma is  op_11_15=0b10000 & is_ind=0 & arx2_8_10 & dma  {
  dma = arx2_8_10;
}

# SBRK - Subtract constant from current AR
#------------------------------------------
# 0111 1100 IIII IIII -  short immediate
:SBRK #short_imm_0_7 is  op_8_15=0b01111100 & short_imm_0_7  {}

# SETC - Set control bits
#-------------------------
# 1011 1110 0100 1111 -  Set C bit
:SETC^" C" is    op_0_15=0b1011111001001111  {
  $(C) = 1;
}
# 1011 1110 0100 0101 -  Set CNF bit
:SETC^" CNF" is  op_0_15=0b1011111001000101  {
  $(CNF) = 1;
}
# 1011 1110 0100 0001 -  Set INTM bit
:SETC^" INTM" is op_0_15=0b1011111001000001  {
  $(INTM) = 1;
}
# 1011 1110 0100 0011 -  Set OVM bit
:SETC^" OVM" is  op_0_15=0b1011111001000011  {
  $(OVM) = 1;
}
# 1011 1110 0100 0111 -  Set SXM bit
:SETC^" SXM" is  op_0_15=0b1011111001000111  {
  $(SXM) = 1;
}
# 1011 1110 0100 1011 -  Set TC bit
:SETC^" TC" is   op_0_15=0b1011111001001011  {
  $(TC) = 1;
}
# 1011 1110 0100 1101 -  Set XF bit
:SETC^" XF" is   op_0_15=0b1011111001001101  {
  $(XF) = 1;
}

# SFL - Shift ACC left
#----------------------
# 1011 1110 0000 1001 -  
:SFL  is  op_0_15=0b1011111000001001  {
  ACC = ACC << 1;
}

# SFR - Shift ACC right
#-----------------------
# 1011 1110 0000 1010 -  
:SFR  is  op_0_15=0b1011111000001010  {
  ACC = ACC >> 1;
}

# SPAC - Subtract PREG from ACC
#-------------------------------
# 1011 1110 0000 0101 -  
:SPAC  is  op_0_15=0b1011111000000101  {
  ACC = ACC - PREG;
}

# SPH - Store high PREG
#-----------------------
# 1000 1101 IAAA AAAA -  direct or indirect

:SPH ind, arx_0_2 is  op_8_15=0b10001101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_sph(ind);
}
:SPH ind is  op_8_15=0b10001101 & is_arx=0 & is_ind=1 & ind  {
  instr_sph(ind);
}
:SPH dma is  op_8_15=0b10001101 & is_ind=0 & dma  {
  instr_sph(dma);
}

# SPL - Store low PREG
#----------------------
# 1000 1100 IAAA AAAA -  direct or indirect
:SPL ind, arx_0_2 is  op_8_15=0b10001100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_spl(ind);
}
:SPL ind is  op_8_15=0b10001100 & is_arx=0 & is_ind=1 & ind  {
  instr_spl(ind);
}
:SPL dma is  op_8_15=0b10001100 & is_ind=0 & dma  {
  instr_spl(dma);
}

# SPLK - Store long immediate to data memory location
#-----------------------------------------------------
# 1010 1110 IAAA AAAA -  direct or indirect
:SPLK #long_imm, ind, arx_0_2 is  op_8_15=0b10101110 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {
  instr_splk(ind, long_imm);
}
:SPLK #long_imm, ind is  op_8_15=0b10101110 & is_arx=0 & is_ind=1 & ind ; long_imm {
  instr_splk(ind, long_imm);
}
:SPLK #long_imm, dma is  op_8_15=0b10101110 & is_ind=0 & dma ; long_imm {
  instr_splk(dma, long_imm);
}

# SPM - Set product shift mode
#------------------------------
# 1011 1111 0000 00PM -  
:SPM pm_0_1 is  op_2_15=0b10111111000000 & pm_0_1  {
  $(PM) = pm_0_1;
}

# SQRA - Square and accumulate previous product
#-----------------------------------------------
# 0101 0010 IAAA AAAA -  direct or indirect
:SQRA ind, arx_0_2 is  op_8_15=0b01010010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SQRA ind is  op_8_15=0b01010010 & is_arx=0 & is_ind=1 & ind  {}
:SQRA dma is  op_8_15=0b01010010 & is_ind=0 & dma  {}

# SQRS - Square and subtract previous product
#---------------------------------------------
# 0101 0011 IAAA AAAA -  direct or indirect
:SQRS ind, arx_0_2 is  op_8_15=0b01010011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SQRS ind is  op_8_15=0b01010011 & is_arx=0 & is_ind=1 & ind  {}
:SQRS dma is  op_8_15=0b01010011 & is_ind=0 & dma  {}

# SST - Store status register
#-----------------------------
# 1000 1110 IAAA AAAA -  ST0, direct or indirect
:SST #0, ind, arx_0_2 is  op_8_15=0b10001110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_sst0(ind);
}
:SST #0, ind is  op_8_15=0b10001110 & is_arx=0 & is_ind=1 & ind  {
  instr_sst0(ind);
}
:SST #0, dma is  op_8_15=0b10001110 & is_ind=0 & dma  {
  instr_sst0(dma);
}
# 1000 1111 IAAA AAAA -  ST1, direct or indirect
:SST #1, ind, arx_0_2 is  op_8_15=0b10001111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_sst1(ind);
}
:SST #1, ind is  op_8_15=0b10001111 & is_arx=0 & is_ind=1 & ind  {
  instr_sst1(ind);
}
:SST #1, dma is  op_8_15=0b10001111 & is_ind=0 & dma  {
  instr_sst1(dma);
}

# SUB - Subtract from ACC
#-------------------------
# 0011 SHFT IAAA AAAA -  with shift of 0 to 15, direct or indirect
:SUB ind is  op_12_15=0b0011 & shft_8_11=0 & is_arx=0 & is_ind=1 & ind  {
  instr_sub(*ind);
}
:SUB ind, shft_8_11, arx_0_2 is  op_12_15=0b0011 & is_arx=1 & is_ind=1 & ind & shft_8_11 & arx_0_2  {
  instr_sub_shift(*ind, shft_8_11);
}
:SUB ind, shft_8_11 is  op_12_15=0b0011 & is_arx=0 & is_ind=1 & ind & shft_8_11  {
  instr_sub_shift(*ind, shft_8_11);
}
:SUB dma is  op_12_15=0b0011 & shft_8_11=0 & is_ind=0 & dma  {
  instr_sub(*dma);
}
:SUB dma, shft_8_11 is  op_12_15=0b0011 & is_ind=0 & dma & shft_8_11  {
  instr_sub_shift(*dma, shft_8_11);
}
# 1011 1111 1010 SHFT -  with shift of 0 to 15, long immediate
:SUB #long_imm is  op_4_15=0b101111111010 & shft_0_3=0 ; long_imm {
  instr_sub(long_imm);
}
:SUB #long_imm, shft_0_3 is  op_4_15=0b101111111010 & shft_0_3 ; long_imm {
  instr_sub_shift(long_imm, shft_0_3);
}
# 0110 0101 IAAA AAAA -  with shift of 16, direct or indirect
:SUB ind, "16", arx_0_2 is  op_8_15=0b01100101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_sub_shift(*ind, 16);
}
:SUB ind, "16" is  op_8_15=0b01100101 & is_arx=0 & is_ind=1 & ind  {
  instr_sub_shift(*ind, 16);
}
:SUB dma, "16" is  op_8_15=0b01100101 & is_ind=0 & dma  {
  instr_sub_shift(*dma, 16);
}
# 1011 1010 IIII IIII -  short immediate
:SUB #short_imm_0_7 is  op_8_15=0b10111010 & short_imm_0_7  {
  instr_sub(short_imm_0_7);
}

# SUBB - Subtract from ACC with borrow
#--------------------------------------
# 0110 0100 IAAA AAAA -  direct or indirect
:SUBB ind, arx_0_2 is  op_8_15=0b01100100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_subb(*ind);
}
:SUBB ind is  op_8_15=0b01100100 & is_arx=0 & is_ind=1 & ind  {
  instr_subb(*ind);
}
:SUBB dma is  op_8_15=0b01100100 & is_ind=0 & dma  {
  instr_subb(*dma);
}

# SUBC - Conditional subtract
#-----------------------------
# 0000 1010 IAAA AAAA -  direct or indirect
:SUBC ind, arx_0_2 is  op_8_15=0b00001010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_subc(*ind);
}
:SUBC ind is  op_8_15=0b00001010 & is_arx=0 & is_ind=1 & ind  {
  instr_subc(*ind);
}
:SUBC dma is  op_8_15=0b00001010 & is_ind=0 & dma  {
  instr_subc(*dma);
}

# SUBS - Subtract from ACC with sign-extension suppressed
#---------------------------------------------------------
# 0110 0110 IAAA AAAA -  direct or indirect
:SUBS ind, arx_0_2 is  op_8_15=0b01100110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_subs(*ind);
}
:SUBS ind is  op_8_15=0b01100110 & is_arx=0 & is_ind=1 & ind  {
  instr_subs(*ind);
}
:SUBS dma is  op_8_15=0b01100110 & is_ind=0 & dma  {
  instr_subs(*dma);
}

# SUBT - Subtract from ACC with shift (0 to 15) specified by TREG
#-----------------------------------------------------------------
# 0110 0111 IAAA AAAA -  direct or indirect
:SUBT ind, arx_0_2 is  op_8_15=0b01100111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_subt(*ind);
}
:SUBT ind is  op_8_15=0b01100111 & is_arx=0 & is_ind=1 & ind  {
  instr_subt(*ind);
}
:SUBT dma is  op_8_15=0b01100111 & is_ind=0 & dma  {
  instr_subt(*dma);
}

# TBLR - Table read
#-------------------
# 1010 0110 IAAA AAAA -  direct or indirect
:TBLR ind, arx_0_2 is  op_8_15=0b10100110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_tblr(ind);
}
:TBLR ind is  op_8_15=0b10100110 & is_arx=0 & is_ind=1 & ind  {
  instr_tblr(ind);
}
:TBLR dma is  op_8_15=0b10100110 & is_ind=0 & dma  {
  instr_tblr(dma);
}

# TBLW - Table write
#--------------------
# 1010 0111 IAAA AAAA -  direct or indirect
:TBLW ind, arx_0_2 is  op_8_15=0b10100111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_tblw(ind);
}
:TBLW ind is  op_8_15=0b10100111 & is_arx=0 & is_ind=1 & ind  {
  instr_tblw(ind);
}
:TBLW dma is  op_8_15=0b10100111 & is_ind=0 & dma  {
  instr_tblw(dma);
}

# TRAP - Software interrupt
#---------------------------
# 1011 1110 0101 0001 -  
:TRAP  is  op_0_15=0b1011111001010001  {}

# XOR - Exclusive OR ACC
#------------------------
# 0110 1100 IAAA AAAA -  with data value, direct or indirect
:XOR ind, arx_0_2 is  op_8_15=0b01101100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {
  instr_xor(*ind);
}
:XOR ind is  op_8_15=0b01101100 & is_arx=0 & is_ind=1 & ind  {
  instr_xor(*ind);
}
:XOR dma is  op_8_15=0b01101100 & is_ind=0 & dma  {
  instr_xor(*dma);
}
# 1011 1111 1101 SHFT -  with shift of 0 to 15, long immediate
:XOR #long_imm is  op_4_15=0b101111111101 & shft_0_3=0 ; long_imm {
  instr_xor(long_imm);
}
:XOR #long_imm, shft_0_3 is  op_4_15=0b101111111101 & shft_0_3 ; long_imm {
  instr_xor_shift(long_imm, shft_0_3);
}
# 1011 1110 1000 0011 -  with shift of 16, long immediate
:XOR #long_imm, "16" is  op_0_15=0b1011111010000011 ; long_imm {
  instr_xor_shift(long_imm, 16);
}

# ZALR - Zero low ACC and load high ACC with rounding
#-----------------------------------------------------
# 0110 1000 IAAA AAAA -  direct or indirect
:ZALR ind, arx_0_2 is  op_8_15=0b01101000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:ZALR ind is  op_8_15=0b01101000 & is_arx=0 & is_ind=1 & ind  {}
:ZALR dma is  op_8_15=0b01101000 & is_ind=0 & dma  {}
