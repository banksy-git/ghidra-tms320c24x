# tms320c24x processor spec 
#   >> see docs/languages/sleigh.htm or sleigh.pdf for Sleigh syntax
# Other language modules (see Ghidra/Processors) may provide better examples
# when creating a new language module.

define endian=little;
define alignment=2;

define space code type=ram_space size=2 wordsize=2 default;
define space ram type=ram_space size=2 wordsize=2;
define space io type=ram_space size=2 wordsize=2;
define space hwstack type=ram_space wordsize=2 size=2;
define space register type=register_space wordsize=2 size=1;

define register offset=0x00 size=2 [ PC ];
define register offset=0x02 size=4 [ ACC PREG ];
define register offset=0x10 size=2 [ TREG AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 ST0 ST1 SP DP ];

macro push(val) {
	*[hwstack]:1 SP = val;
	SP = SP + 1;
}

macro pop(rval) {	
#	CheckStackUnderflow();
  SP = SP - 1;
	rval = *[hwstack]:1 SP;
}


define token inst(16)
  # OPCode prefixes
  op_0_15 = (0, 15)
  op_1_15 = (1, 15)
  op_2_15 = (2, 15)
  op_3_15 = (3, 15)
  op_4_15 = (4, 15)
  op_5_15 = (5, 15)
  op_6_15 = (6, 15)
  op_7_15 = (7, 15)
  op_8_15 = (8, 15)
  op_9_15 = (9, 15)
  op_10_15 = (10, 15)
  op_11_15 = (11, 15)
  op_12_15 = (12, 15)
  op_13_15 = (13, 15)
  op_14_15 = (14, 15)

  shft_8_11 = (8, 11)
  shf_8_10 = (8, 10)
  shft_0_3 = (0, 3)
  short_imm_0_7 = (0, 7)

  tpzlvczlvc_0_9 = (0, 9)
  bitx_8_11 = (8, 11)
  cm_0_1 = (0, 1)
  pm_0_1 = (0, 1)
  ntr_0_3 = (0, 3)
  addr9_0_8 = (0, 8)
  addr13_0_12 = (0, 12)
  arx2_8_10 = (8, 10)

  # Direct / Indirect 
  dma_0_6 = (0, 6)
  arx_0_2 = (0, 2)
  arx2_0_2 = (0, 2)
  is_arx = (3, 3)
  aru_4_6 = (4, 6)
  is_ind = (7, 7)


;

define token data16 (16)
   imm16 = (0,15)
;

pma: imm16 is imm16	{ 
  export *[code]:2 imm16; 
}

long_imm: imm16 is imm16	{ 
  export imm16; 
}

dma: dma_0_6 is dma_0_6 {
  val:2 = (DP << 7) | dma_0_6;
  export *[ram]:2 val; 
}

attach variables [ arx_0_2 ] [ AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 ];

ind: "*"        is aru_4_6=0b000 { export 0:2;}
ind: "*-"       is aru_4_6=0b001 { export 1:2;}
ind: "*+"       is aru_4_6=0b010 { export 2:2;}
ind: "reserved" is aru_4_6=0b011 { export 3:2;}
ind: "*BR0-"    is aru_4_6=0b100 { export 4:2;}
ind: "*0-"      is aru_4_6=0b101 { export 5:2;}
ind: "*0+"      is aru_4_6=0b110 { export 6:2;}
ind: "*BR0-"    is aru_4_6=0b111 { export 7:2;}

# ABS - Absolute value of ACC
#-----------------------------
# 1011 1110 0000 0000 -  
:ABS  is  op_0_15=0b1011111000000000  {}

# ADD - Add to ACC
#------------------
# 0010 SHFT IAAA AAAA -  shift 0 to 15, direct or indirect
:ADD ind is  op_12_15=0b0010 & shft_8_11=0 & is_arx=0 & is_ind=1 & ind  {}
:ADD ind, shft_8_11, arx_0_2 is  op_12_15=0b0010 & is_arx=1 & is_ind=1 & ind & shft_8_11 & arx_0_2  {}
:ADD ind, shft_8_11 is  op_12_15=0b0010 & is_arx=0 & is_ind=1 & ind & shft_8_11  {}
:ADD dma is  op_12_15=0b0010 & shft_8_11=0 & is_ind=0 & dma  {}
:ADD dma, shft_8_11 is  op_12_15=0b0010 & is_ind=0 & dma & shft_8_11  {
  ACC = (ACC + *dma) << shft_8_11;
}
# 1011 1111 1001 SHFT -  shift 0 to 15, long immediate
:ADD #long_imm is  op_4_15=0b101111111001 & shft_0_3=0 ; long_imm {}
:ADD #long_imm, shft_0_3 is  op_4_15=0b101111111001 & shft_0_3 ; long_imm {}
# 0110 0001 IAAA AAAA -  shift of 16, direct or indirect
:ADD ind, "16", arx_0_2 is  op_8_15=0b01100001 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:ADD ind, "16" is  op_8_15=0b01100001 & is_arx=0 & is_ind=1 & ind  {}
:ADD dma, "16" is  op_8_15=0b01100001 & is_ind=0 & dma  {}
# 1011 1000 IIII IIII -  short immediate
:ADD #short_imm_0_7 is  op_8_15=0b10111000 & short_imm_0_7  {}

# ADDC - Add to ACC with carry
#------------------------------
# 0110 0000 IAAA AAAA -  direct or indirect
:ADDC ind, arx_0_2 is  op_8_15=0b01100000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:ADDC ind is  op_8_15=0b01100000 & is_arx=0 & is_ind=1 & ind  {}
:ADDC dma is  op_8_15=0b01100000 & is_ind=0 & dma  {}

# ADDS - Add to low ACC with sign-extension suppressed
#------------------------------------------------------
# 0110 0010 IAAA AAAA -  direct or indirect
:ADDS ind, arx_0_2 is  op_8_15=0b01100010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:ADDS ind is  op_8_15=0b01100010 & is_arx=0 & is_ind=1 & ind  {}
:ADDS dma is  op_8_15=0b01100010 & is_ind=0 & dma  {}

# ADDT - Add to ACC with shift (0 to 15) specified by TREG
#----------------------------------------------------------
# 0110 0011 IAAA AAAA -  direct or indirect
:ADDT ind, arx_0_2 is  op_8_15=0b01100011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:ADDT ind is  op_8_15=0b01100011 & is_arx=0 & is_ind=1 & ind  {}
:ADDT dma is  op_8_15=0b01100011 & is_ind=0 & dma  {}

# ADRK - Add constant to current AR
#-----------------------------------
# 0111 1000 IIII IIII -  short immediate
:ADRK #short_imm_0_7 is  op_8_15=0b01111000 & short_imm_0_7  {}

# AND - AND ACC
#---------------
# 0110 1110 IAAA AAAA -  with data value, direct or indirect
:AND ind, arx_0_2 is  op_8_15=0b01101110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:AND ind is  op_8_15=0b01101110 & is_arx=0 & is_ind=1 & ind  {}
:AND dma is  op_8_15=0b01101110 & is_ind=0 & dma  {}
# 1011 1111 1011 SHFT -  with shift 0 to 15, long immediate
:AND #long_imm is  op_4_15=0b101111111011 & shft_0_3=0 ; long_imm {}
:AND #long_imm, shft_0_3 is  op_4_15=0b101111111011 & shft_0_3 ; long_imm {}
# 1011 1110 1000 0001 -  with shift of 16, long immediate
:AND #long_imm, "16" is  op_0_15=0b1011111010000001 ; long_imm {}

# APAC - Add PREG to ACC
#------------------------
# 1011 1110 0000 0100 -  
:APAC  is  op_0_15=0b1011111000000100  {}

# B - Branch unconditionally
#----------------------------
# 0111 1001 1AAA AAAA -  indirect
:B pma, ind, arx_0_2 is  op_7_15=0b011110011 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {
  goto pma;
}
:B pma, ind is  op_7_15=0b011110011 & is_arx=0 & is_ind=1 & ind ; pma {
  goto pma;
}

# BACC - Branch to address specified by ACC
#-------------------------------------------
# 1011 1110 0010 0000 -  
:BACC  is  op_0_15=0b1011111000100000  {
  goto [ACC];
}

# BANZ - Branch on current AR not 0
#-----------------------------------
# 0111 1011 1AAA AAAA -  indirect
:BANZ pma, ind, arx_0_2 is  op_7_15=0b011110111 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {}
:BANZ pma, ind is  op_7_15=0b011110111 & is_arx=0 & is_ind=1 & ind ; pma {}

# BCND - Branch conditionally
#-----------------------------
# 1110 00TP ZLVC ZLVC -  
:BCND pma, tpzlvczlvc_0_9 is  op_10_15=0b111000 & tpzlvczlvc_0_9 ; pma {}

# BIT - Test bit
#----------------
# 0100 BITX IAAA AAAA -  direct or indirect
:BIT ind, bitx_8_11, arx_0_2 is  op_12_15=0b0100 & is_arx=1 & is_ind=1 & ind & bitx_8_11 & arx_0_2  {}
:BIT ind, bitx_8_11 is  op_12_15=0b0100 & is_arx=0 & is_ind=1 & ind & bitx_8_11  {}
:BIT dma, bitx_8_11 is  op_12_15=0b0100 & is_ind=0 & dma & bitx_8_11  {}

# BITT - Test bit specified by TREG
#-----------------------------------
# 0110 1111 IAAA AAAA -  direct or indirect
:BITT ind, arx_0_2 is  op_8_15=0b01101111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:BITT ind is  op_8_15=0b01101111 & is_arx=0 & is_ind=1 & ind  {}
:BITT dma is  op_8_15=0b01101111 & is_ind=0 & dma  {}

# BLDD - Block move from data memory to data memory
#---------------------------------------------------
# 1010 1000 IAAA AAAA -  direct/indirect with long immediate source
:BLDD #long_imm, ind, arx_0_2 is  op_8_15=0b10101000 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {}
:BLDD #long_imm, ind is  op_8_15=0b10101000 & is_arx=0 & is_ind=1 & ind ; long_imm {}
:BLDD #long_imm, dma is  op_8_15=0b10101000 & is_ind=0 & dma ; long_imm {}
# 1010 1001 IAAA AAAA -  direct/indirect with long immediate destination
:BLDD #long_imm, ind, arx_0_2 is  op_8_15=0b10101001 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {}
:BLDD #long_imm, ind is  op_8_15=0b10101001 & is_arx=0 & is_ind=1 & ind ; long_imm {}
:BLDD #long_imm, dma is  op_8_15=0b10101001 & is_ind=0 & dma ; long_imm {}

# BLPD - Block move from program memory to data memory
#------------------------------------------------------
# 1010 0101 IAAA AAAA -  direct/indirect with long immediate source
:BLPD pma, ind, arx_0_2 is  op_8_15=0b10100101 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {}
:BLPD pma, ind is  op_8_15=0b10100101 & is_arx=0 & is_ind=1 & ind ; pma {}
:BLPD pma, dma is  op_8_15=0b10100101 & is_ind=0 & dma ; pma {}

# CALA - Call subroutine at location specified by ACC
#-----------------------------------------------------
# 1011 1110 0011 0000 -  
:CALA  is  op_0_15=0b1011111000110000  {
  push(&:1 inst_next);
  call [ACC];
}

# CALL - Call subroutine
#------------------------
# 0111 1010 1AAA AAAA -  indirect
:CALL pma, ind, arx_0_2 is  op_7_15=0b011110101 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {
  push(&:1 inst_next);
  call pma;
}
:CALL pma, ind is  op_7_15=0b011110101 & is_arx=0 & is_ind=1 & ind ; pma {
  push(&:1 inst_next);
  call pma;
}

# CC - Call conditionally
#-------------------------
# 1110 10TP ZLVC ZLVC -  
:CC pma, tpzlvczlvc_0_9 is  op_10_15=0b111010 & tpzlvczlvc_0_9 ; pma {}

# CLRC - Clear control bits
#---------------------------
# 1011 1110 0100 1110 -  Clear C bit
:CLRC "C" is  op_0_15=0b1011111001001110  {}
# 1011 1110 0100 0100 -  Clear CNF bit
:CLRC "CNF" is  op_0_15=0b1011111001000100  {}
# 1011 1110 0100 0000 -  Clear INTM bit
:CLRC "INTM" is  op_0_15=0b1011111001000000  {}
# 1011 1110 0100 0010 -  Clear OVM bit
:CLRC "OVM" is  op_0_15=0b1011111001000010  {}
# 1011 1110 0100 0110 -  Clear SXM bit
:CLRC "SXM" is  op_0_15=0b1011111001000110  {}
# 1011 1110 0100 1010 -  Clear TC bit
:CLRC "TC" is  op_0_15=0b1011111001001010  {}
# 1011 1110 0100 1100 -  Clear XF bit
:CLRC "XF" is  op_0_15=0b1011111001001100  {}

# CMPL - Complement ACC
#-----------------------
# 1011 1110 0000 0001 -  
:CMPL  is  op_0_15=0b1011111000000001  {}

# CMPR - Compare current AR with AR0
#------------------------------------
# 1011 1111 0100 01CM -  
:CMPR cm_0_1 is  op_2_15=0b10111111010001 & cm_0_1  {}

# DMOV - Data move in data memory
#---------------------------------
# 0111 0111 IAAA AAAA -  direct or indirect
:DMOV ind, arx_0_2 is  op_8_15=0b01110111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:DMOV ind is  op_8_15=0b01110111 & is_arx=0 & is_ind=1 & ind  {}
:DMOV dma is  op_8_15=0b01110111 & is_ind=0 & dma  {}

# IDLE - Idle until interrupt
#-----------------------------
# 1011 1110 0010 0010 -  
:IDLE  is  op_0_15=0b1011111000100010  {}

# IN - Input data from I/O location
#-----------------------------------
# 1010 1111 IAAA AAAA -  direct or indirect
:IN #long_imm, ind, arx_0_2 is  op_8_15=0b10101111 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {}
:IN #long_imm, ind is  op_8_15=0b10101111 & is_arx=0 & is_ind=1 & ind ; long_imm {}
:IN #long_imm, dma is  op_8_15=0b10101111 & is_ind=0 & dma ; long_imm {}

# INTR - Soft interrupt
#-----------------------
# 1011 1110 0111 NTR# -  
:INTR ntr_0_3 is  op_4_15=0b101111100111 & ntr_0_3  {}

# LACC - Load ACC
#-----------------
# 0001 SHFT IAAA AAAA -  shift 0 to 15, direct or indirect
:LACC ind is  op_12_15=0b0001 & shft_8_11=0 & is_arx=0 & is_ind=1 & ind  {}
:LACC ind, shft_8_11, arx_0_2 is  op_12_15=0b0001 & is_arx=1 & is_ind=1 & ind & shft_8_11 & arx_0_2  {}
:LACC ind, shft_8_11 is  op_12_15=0b0001 & is_arx=0 & is_ind=1 & ind & shft_8_11  {}
:LACC dma is  op_12_15=0b0001 & shft_8_11=0 & is_ind=0 & dma  {}
:LACC dma, shft_8_11 is  op_12_15=0b0001 & is_ind=0 & dma & shft_8_11  {}
# 1011 1111 1000 SHFT -  shift 0 to 15, long immediate
:LACC #long_imm is  op_4_15=0b101111111000 & shft_0_3=0 ; long_imm {
  ACC = long_imm;
}
:LACC #long_imm, shft_0_3 is  op_4_15=0b101111111000 & shft_0_3 ; long_imm {
  ACC = long_imm << shft_0_3;
}
# 0110 1010 IAAA AAAA -  shift of 16, direct or indirect
:LACC ind, "16", arx_0_2 is  op_8_15=0b01101010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LACC ind, "16" is  op_8_15=0b01101010 & is_arx=0 & is_ind=1 & ind  {}
:LACC dma, "16" is  op_8_15=0b01101010 & is_ind=0 & dma  {}

# LACL - Load low word of ACC
#-----------------------------
# 0110 1001 IAAA AAAA -  direct or indirect
:LACL ind, arx_0_2 is  op_8_15=0b01101001 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LACL ind is  op_8_15=0b01101001 & is_arx=0 & is_ind=1 & ind  {}
:LACL dma is  op_8_15=0b01101001 & is_ind=0 & dma  {}
# 1011 1001 IIII IIII -  short immediate
:LACL #short_imm_0_7 is  op_8_15=0b10111001 & short_imm_0_7  {}

# LACT - Load ACC with shift (0 to 15) specified by TREG
#--------------------------------------------------------
# 0110 1011 IAAA AAAA -  direct or indirect
:LACT ind, arx_0_2 is  op_8_15=0b01101011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LACT ind is  op_8_15=0b01101011 & is_arx=0 & is_ind=1 & ind  {}
:LACT dma is  op_8_15=0b01101011 & is_ind=0 & dma  {}

# LAR - Load specified AR
#-------------------------
# 0000 0ARX IAAA AAAA -  from specified data location, direct or indirect
:LAR arx2_8_10, ind, arx_0_2 is  op_11_15=0b00000 & is_arx=1 & is_ind=1 & arx2_8_10 & ind & arx_0_2  {}
:LAR arx2_8_10, ind is  op_11_15=0b00000 & is_arx=0 & is_ind=1 & arx2_8_10 & ind  {}
:LAR arx2_8_10, dma is  op_11_15=0b00000 & is_ind=0 & arx2_8_10 & dma  {}
# 1011 0ARX IIII IIII -  with constant, short immediate
:LAR arx2_8_10, #short_imm_0_7 is  op_11_15=0b10110 & arx2_8_10 & short_imm_0_7  {}
# 1011 1111 0000 1ARX -  with constant, long immediate
:LAR #long_imm, arx2_0_2 is  op_3_15=0b1011111100001 & arx2_0_2 ; long_imm {}

# LDP - Load data page pointer
#------------------------------
# 0000 1101 IAAA AAAA -  direct or indirect
:LDP ind, arx_0_2 is  op_8_15=0b00001101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LDP ind is  op_8_15=0b00001101 & is_arx=0 & is_ind=1 & ind  {}
:LDP dma is  op_8_15=0b00001101 & is_ind=0 & dma  {}
# 1011 110I IIII IIII -  short immediate
:LDP addr9_0_8 is  op_9_15=0b1011110 & addr9_0_8  {
  DP = addr9_0_8;
}

# LPH - Load high PREG
#----------------------
# 0111 0101 IAAA AAAA -  direct or indirect
:LPH ind, arx_0_2 is  op_8_15=0b01110101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LPH ind is  op_8_15=0b01110101 & is_arx=0 & is_ind=1 & ind  {}
:LPH dma is  op_8_15=0b01110101 & is_ind=0 & dma  {}

# LST - Load status register
#----------------------------
# 0000 1110 IAAA AAAA -  ST0, direct or indirect
:LST ind, arx_0_2 is  op_8_15=0b00001110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LST ind is  op_8_15=0b00001110 & is_arx=0 & is_ind=1 & ind  {}
:LST dma is  op_8_15=0b00001110 & is_ind=0 & dma  {}
# 0000 1111 IAAA AAAA -  ST1, direct or indirect
:LST ind, arx_0_2 is  op_8_15=0b00001111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LST ind is  op_8_15=0b00001111 & is_arx=0 & is_ind=1 & ind  {}
:LST dma is  op_8_15=0b00001111 & is_ind=0 & dma  {}

# LT - Load TREG
#----------------
# 0111 0011 IAAA AAAA -  direct or indirect
:LT ind, arx_0_2 is  op_8_15=0b01110011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LT ind is  op_8_15=0b01110011 & is_arx=0 & is_ind=1 & ind  {}
:LT dma is  op_8_15=0b01110011 & is_ind=0 & dma  {}

# LTA - Load TREG and accumulate previous product
#-------------------------------------------------
# 0111 0000 IAAA AAAA -  direct or indirect
:LTA ind, arx_0_2 is  op_8_15=0b01110000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LTA ind is  op_8_15=0b01110000 & is_arx=0 & is_ind=1 & ind  {}
:LTA dma is  op_8_15=0b01110000 & is_ind=0 & dma  {}

# LTD - Load TREG, accumulate previous product, and move data
#-------------------------------------------------------------
# 0111 0010 IAAA AAAA -  direct or indirect
:LTD ind, arx_0_2 is  op_8_15=0b01110010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LTD ind is  op_8_15=0b01110010 & is_arx=0 & is_ind=1 & ind  {}
:LTD dma is  op_8_15=0b01110010 & is_ind=0 & dma  {}

# LTP - Load TREG and store PREG in accumulator
#-----------------------------------------------
# 0111 0001 IAAA AAAA -  direct or indirect
:LTP ind, arx_0_2 is  op_8_15=0b01110001 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LTP ind is  op_8_15=0b01110001 & is_arx=0 & is_ind=1 & ind  {}
:LTP dma is  op_8_15=0b01110001 & is_ind=0 & dma  {}

# LTS - Load TREG and subtract previous product
#-----------------------------------------------
# 0111 0100 IAAA AAAA -  direct or indirect
:LTS ind, arx_0_2 is  op_8_15=0b01110100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:LTS ind is  op_8_15=0b01110100 & is_arx=0 & is_ind=1 & ind  {}
:LTS dma is  op_8_15=0b01110100 & is_ind=0 & dma  {}

# MAC - Multiply and accumulate
#-------------------------------
# 1010 0010 IAAA AAAA -  direct or indirect
:MAC pma, ind, arx_0_2 is  op_8_15=0b10100010 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {}
:MAC pma, ind is  op_8_15=0b10100010 & is_arx=0 & is_ind=1 & ind ; pma {}
:MAC pma, dma is  op_8_15=0b10100010 & is_ind=0 & dma ; pma {}

# MACD - Multiply and accumulate with data move
#-----------------------------------------------
# 1010 0011 IAAA AAAA -  direct or indirect
:MACD pma, ind, arx_0_2 is  op_8_15=0b10100011 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; pma {}
:MACD pma, ind is  op_8_15=0b10100011 & is_arx=0 & is_ind=1 & ind ; pma {}
:MACD pma, dma is  op_8_15=0b10100011 & is_ind=0 & dma ; pma {}

# MAR - Modify current AR and/or ARP
#------------------------------------
# 1000 1011 IAAA AAAA -  indirect (performs no operation when direct)
:MAR ind, arx_0_2 is  op_8_15=0b10001011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MAR ind is  op_8_15=0b10001011 & is_arx=0 & is_ind=1 & ind  {}
:MAR dma is  op_8_15=0b10001011 & is_ind=0 & dma  {}

# MPY - Multiply TREG
#---------------------
# 0101 0100 IAAA AAAA -  by data value, direct or indirect
:MPY ind, arx_0_2 is  op_8_15=0b01010100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MPY ind is  op_8_15=0b01010100 & is_arx=0 & is_ind=1 & ind  {}
:MPY dma is  op_8_15=0b01010100 & is_ind=0 & dma  {}
# 110I IIII IIII IIII -  by 13-bit constant, short immediate
:MPY addr13_0_12 is  op_13_15=0b110 & addr13_0_12  {}

# MPYA - Multiply and accumulate previous product
#-------------------------------------------------
# 0101 0000 IAAA AAAA -  direct or indirect
:MPYA ind, arx_0_2 is  op_8_15=0b01010000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MPYA ind is  op_8_15=0b01010000 & is_arx=0 & is_ind=1 & ind  {}
:MPYA dma is  op_8_15=0b01010000 & is_ind=0 & dma  {}

# MPYS - Multiply and subtract previous product
#-----------------------------------------------
# 0101 0001 IAAA AAAA -  direct or indirect
:MPYS ind, arx_0_2 is  op_8_15=0b01010001 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MPYS ind is  op_8_15=0b01010001 & is_arx=0 & is_ind=1 & ind  {}
:MPYS dma is  op_8_15=0b01010001 & is_ind=0 & dma  {}

# MPYU - Multiply unsigned
#--------------------------
# 0101 0101 IAAA AAAA -  direct or indirect
:MPYU ind, arx_0_2 is  op_8_15=0b01010101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:MPYU ind is  op_8_15=0b01010101 & is_arx=0 & is_ind=1 & ind  {}
:MPYU dma is  op_8_15=0b01010101 & is_ind=0 & dma  {}

# NEG - Negate ACC
#------------------
# 1011 1110 0000 0010 -  
:NEG  is  op_0_15=0b1011111000000010  {}

# NMI - Nonmaskable interrupt
#-----------------------------
# 1011 1110 0101 0010 -  
:NMI  is  op_0_15=0b1011111001010010  {}

# NOP - No operation
#--------------------
# 1000 1011 0000 0000 -  
:NOP  is  op_0_15=0b1000101100000000  {}

# NORM - Normalize the contents of ACC
#--------------------------------------
# 1010 0000 IAAA AAAA -  indirect
:NORM ind, arx_0_2 is  op_8_15=0b10100000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:NORM ind is  op_8_15=0b10100000 & is_arx=0 & is_ind=1 & ind  {}
:NORM dma is  op_8_15=0b10100000 & is_ind=0 & dma  {}

# OR - OR ACC
#-------------
# 0110 1101 IAAA AAAA -  with data value, direct or indirect
:OR ind, arx_0_2 is  op_8_15=0b01101101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:OR ind is  op_8_15=0b01101101 & is_arx=0 & is_ind=1 & ind  {}
:OR dma is  op_8_15=0b01101101 & is_ind=0 & dma  {}
# 1011 1111 1100 SHFT -  with shift 0 to 15, long immediate
:OR #long_imm is  op_4_15=0b101111111100 & shft_0_3=0 ; long_imm {}
:OR #long_imm, shft_0_3 is  op_4_15=0b101111111100 & shft_0_3 ; long_imm {}
# 1011 1110 1000 0010 -  with shift of 16, long immediate
:OR #long_imm, "16" is  op_0_15=0b1011111010000010 ; long_imm {}

# OUT - Output data to port
#---------------------------
# 0000 1100 IAAA AAAA -  direct or indirect
:OUT #long_imm, ind, arx_0_2 is  op_8_15=0b00001100 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {}
:OUT #long_imm, ind is  op_8_15=0b00001100 & is_arx=0 & is_ind=1 & ind ; long_imm {}
:OUT #long_imm, dma is  op_8_15=0b00001100 & is_ind=0 & dma ; long_imm {}

# PAC - Load ACC with PREG
#--------------------------
# 1011 1110 0000 0011 -  
:PAC  is  op_0_15=0b1011111000000011  {}

# POP - Pop top of stack to low ACC
#-----------------------------------
# 1011 1110 0011 0010 -  
:POP  is  op_0_15=0b1011111000110010  {}

# POPD - Pop top of stack to data memory
#----------------------------------------
# 1000 1010 IAAA AAAA -  direct or indirect
:POPD ind, arx_0_2 is  op_8_15=0b10001010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:POPD ind is  op_8_15=0b10001010 & is_arx=0 & is_ind=1 & ind  {}
:POPD dma is  op_8_15=0b10001010 & is_ind=0 & dma  {}

# PSHD - Push data memory value on stack
#----------------------------------------
# 0111 0110 IAAA AAAA -  direct or indirect
:PSHD ind, arx_0_2 is  op_8_15=0b01110110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:PSHD ind is  op_8_15=0b01110110 & is_arx=0 & is_ind=1 & ind  {}
:PSHD dma is  op_8_15=0b01110110 & is_ind=0 & dma  {}

# PUSH - Push low ACC onto stack
#--------------------------------
# 1011 1110 0011 1100 -  
:PUSH  is  op_0_15=0b1011111000111100  {}

# RET - Return from subroutine
#------------------------------
# 1110 1111 0000 0000 -  
:RET  is  op_0_15=0b1110111100000000  {}

# RETC - Return conditionally
#-----------------------------
# 1110 11TP ZLVC ZLVC -  
:RETC tpzlvczlvc_0_9 is  op_10_15=0b111011 & tpzlvczlvc_0_9  {}

# ROL - Rotate ACC left
#-----------------------
# 1011 1110 0000 1100 -  
:ROL  is  op_0_15=0b1011111000001100  {}

# ROR - Rotate ACC right
#------------------------
# 1011 1110 0000 1101 -  
:ROR  is  op_0_15=0b1011111000001101  {}

# RPT - Repeat next instruction
#-------------------------------
# 0000 1011 IAAA AAAA -  direct or indirect
:RPT ind, arx_0_2 is  op_8_15=0b00001011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:RPT ind is  op_8_15=0b00001011 & is_arx=0 & is_ind=1 & ind  {}
:RPT dma is  op_8_15=0b00001011 & is_ind=0 & dma  {}
# 1011 1011 IIII IIII -  short immediate
:RPT #short_imm_0_7 is  op_8_15=0b10111011 & short_imm_0_7  {}

# SACH - Store high ACC
#-----------------------
# 1001 1SHF IAAA AAAA -  shift 0 to 7, direct or indirect
:SACH ind is  op_11_15=0b10011 & shf_8_10=0 & is_arx=0 & is_ind=1 & ind  {}
:SACH ind, shf_8_10, arx_0_2 is  op_11_15=0b10011 & is_arx=1 & is_ind=1 & ind & shf_8_10 & arx_0_2  {}
:SACH ind, shf_8_10 is  op_11_15=0b10011 & is_arx=0 & is_ind=1 & ind & shf_8_10  {}
:SACH dma is  op_11_15=0b10011 & shf_8_10=0 & is_ind=0 & dma  {}
:SACH dma, shf_8_10 is  op_11_15=0b10011 & is_ind=0 & dma & shf_8_10  {}

# SACL - Store low ACC
#----------------------
# 1001 0SHF IAAA AAAA -  shift 0 to 7, direct or indirect
:SACL ind is  op_11_15=0b10010 & shf_8_10=0 & is_arx=0 & is_ind=1 & ind  {}
:SACL ind, shf_8_10, arx_0_2 is  op_11_15=0b10010 & is_arx=1 & is_ind=1 & ind & shf_8_10 & arx_0_2  {}
:SACL ind, shf_8_10 is  op_11_15=0b10010 & is_arx=0 & is_ind=1 & ind & shf_8_10  {}
:SACL dma is  op_11_15=0b10010 & shf_8_10=0 & is_ind=0 & dma  {}
:SACL dma, shf_8_10 is  op_11_15=0b10010 & is_ind=0 & dma & shf_8_10  {}

# SAR - Store specified AR
#--------------------------
# 1000 0ARX IAAA AAAA -  to specified data location, direct or indirect
:SAR arx2_8_10, ind, arx_0_2 is  op_11_15=0b10000 & is_arx=1 & is_ind=1 & arx2_8_10 & ind & arx_0_2  {}
:SAR arx2_8_10, ind is  op_11_15=0b10000 & is_arx=0 & is_ind=1 & arx2_8_10 & ind  {}
:SAR arx2_8_10, dma is  op_11_15=0b10000 & is_ind=0 & arx2_8_10 & dma  {}

# SBRK - Subtract constant from current AR
#------------------------------------------
# 0111 1100 IIII IIII -  short immediate
:SBRK #short_imm_0_7 is  op_8_15=0b01111100 & short_imm_0_7  {}

# SETC - Set control bits
#-------------------------
# 1011 1110 0100 1111 -  Set C bit
:SETC^" C" is    op_0_15=0b1011111001001111  {}
# 1011 1110 0100 0101 -  Set CNF bit
:SETC^" CNF" is  op_0_15=0b1011111001000101  {}
# 1011 1110 0100 0001 -  Set INTM bit
:SETC^" INTM" is op_0_15=0b1011111001000001  {}
# 1011 1110 0100 0011 -  Set OVM bit
:SETC^" OVM" is  op_0_15=0b1011111001000011  {}
# 1011 1110 0100 0111 -  Set SXM bit
:SETC^" SXM" is  op_0_15=0b1011111001000111  {}
# 1011 1110 0100 1011 -  Set TC bit
:SETC^" TC" is   op_0_15=0b1011111001001011  {}
# 1011 1110 0100 1101 -  Set XF bit
:SETC^" XF" is   op_0_15=0b1011111001001101  {}

# SFL - Shift ACC left
#----------------------
# 1011 1110 0000 1001 -  
:SFL  is  op_0_15=0b1011111000001001  {}

# SFR - Shift ACC right
#-----------------------
# 1011 1110 0000 1010 -  
:SFR  is  op_0_15=0b1011111000001010  {}

# SPAC - Subtract PREG from ACC
#-------------------------------
# 1011 1110 0000 0101 -  
:SPAC  is  op_0_15=0b1011111000000101  {}

# SPH - Store high PREG
#-----------------------
# 1000 1101 IAAA AAAA -  direct or indirect
:SPH ind, arx_0_2 is  op_8_15=0b10001101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SPH ind is  op_8_15=0b10001101 & is_arx=0 & is_ind=1 & ind  {}
:SPH dma is  op_8_15=0b10001101 & is_ind=0 & dma  {}

# SPL - Store low PREG
#----------------------
# 1000 1100 IAAA AAAA -  direct or indirect
:SPL ind, arx_0_2 is  op_8_15=0b10001100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SPL ind is  op_8_15=0b10001100 & is_arx=0 & is_ind=1 & ind  {}
:SPL dma is  op_8_15=0b10001100 & is_ind=0 & dma  {}

# SPLK - Store long immediate to data memory location
#-----------------------------------------------------
# 1010 1110 IAAA AAAA -  direct or indirect
:SPLK #long_imm, ind, arx_0_2 is  op_8_15=0b10101110 & is_arx=1 & is_ind=1 & ind & arx_0_2 ; long_imm {}
:SPLK #long_imm, ind is  op_8_15=0b10101110 & is_arx=0 & is_ind=1 & ind ; long_imm {}
:SPLK #long_imm, dma is  op_8_15=0b10101110 & is_ind=0 & dma ; long_imm {
  dma = long_imm;
}

# SPM - Set product shift mode
#------------------------------
# 1011 1111 0000 00PM -  
:SPM pm_0_1 is  op_2_15=0b10111111000000 & pm_0_1  {}

# SQRA - Square and accumulate previous product
#-----------------------------------------------
# 0101 0010 IAAA AAAA -  direct or indirect
:SQRA ind, arx_0_2 is  op_8_15=0b01010010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SQRA ind is  op_8_15=0b01010010 & is_arx=0 & is_ind=1 & ind  {}
:SQRA dma is  op_8_15=0b01010010 & is_ind=0 & dma  {}

# SQRS - Square and subtract previous product
#---------------------------------------------
# 0101 0011 IAAA AAAA -  direct or indirect
:SQRS ind, arx_0_2 is  op_8_15=0b01010011 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SQRS ind is  op_8_15=0b01010011 & is_arx=0 & is_ind=1 & ind  {}
:SQRS dma is  op_8_15=0b01010011 & is_ind=0 & dma  {}

# SST - Store status register
#-----------------------------
# 1000 1110 IAAA AAAA -  ST0, direct or indirect
:SST ind, arx_0_2 is  op_8_15=0b10001110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SST ind is  op_8_15=0b10001110 & is_arx=0 & is_ind=1 & ind  {}
:SST dma is  op_8_15=0b10001110 & is_ind=0 & dma  {}
# 1000 1111 IAAA AAAA -  ST1, direct or indirect
:SST ind, arx_0_2 is  op_8_15=0b10001111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SST ind is  op_8_15=0b10001111 & is_arx=0 & is_ind=1 & ind  {}
:SST dma is  op_8_15=0b10001111 & is_ind=0 & dma  {}

# SUB - Subtract from ACC
#-------------------------
# 0011 SHFT IAAA AAAA -  with shift of 0 to 15, direct or indirect
:SUB ind is  op_12_15=0b0011 & shft_8_11=0 & is_arx=0 & is_ind=1 & ind  {}
:SUB ind, shft_8_11, arx_0_2 is  op_12_15=0b0011 & is_arx=1 & is_ind=1 & ind & shft_8_11 & arx_0_2  {}
:SUB ind, shft_8_11 is  op_12_15=0b0011 & is_arx=0 & is_ind=1 & ind & shft_8_11  {}
:SUB dma is  op_12_15=0b0011 & shft_8_11=0 & is_ind=0 & dma  {}
:SUB dma, shft_8_11 is  op_12_15=0b0011 & is_ind=0 & dma & shft_8_11  {}
# 1011 1111 1010 SHFT -  with shift of 0 to 15, long immediate
:SUB #long_imm is  op_4_15=0b101111111010 & shft_0_3=0 ; long_imm {}
:SUB #long_imm, shft_0_3 is  op_4_15=0b101111111010 & shft_0_3 ; long_imm {}
# 0110 0101 IAAA AAAA -  with shift of 16, direct or indirect
:SUB ind, "16", arx_0_2 is  op_8_15=0b01100101 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SUB ind, "16" is  op_8_15=0b01100101 & is_arx=0 & is_ind=1 & ind  {}
:SUB dma, "16" is  op_8_15=0b01100101 & is_ind=0 & dma  {}
# 1011 1010 IIII IIII -  short immediate
:SUB #short_imm_0_7 is  op_8_15=0b10111010 & short_imm_0_7  {}

# SUBB - Subtract from ACC with borrow
#--------------------------------------
# 0110 0100 IAAA AAAA -  direct or indirect
:SUBB ind, arx_0_2 is  op_8_15=0b01100100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SUBB ind is  op_8_15=0b01100100 & is_arx=0 & is_ind=1 & ind  {}
:SUBB dma is  op_8_15=0b01100100 & is_ind=0 & dma  {}

# SUBC - Conditional subtract
#-----------------------------
# 0000 1010 IAAA AAAA -  direct or indirect
:SUBC ind, arx_0_2 is  op_8_15=0b00001010 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SUBC ind is  op_8_15=0b00001010 & is_arx=0 & is_ind=1 & ind  {}
:SUBC dma is  op_8_15=0b00001010 & is_ind=0 & dma  {}

# SUBS - Subtract from ACC with sign-extension suppressed
#---------------------------------------------------------
# 0110 0110 IAAA AAAA -  direct or indirect
:SUBS ind, arx_0_2 is  op_8_15=0b01100110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SUBS ind is  op_8_15=0b01100110 & is_arx=0 & is_ind=1 & ind  {}
:SUBS dma is  op_8_15=0b01100110 & is_ind=0 & dma  {}

# SUBT - Subtract from ACC with shift (0 to 15) specified by TREG
#-----------------------------------------------------------------
# 0110 0111 IAAA AAAA -  direct or indirect
:SUBT ind, arx_0_2 is  op_8_15=0b01100111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:SUBT ind is  op_8_15=0b01100111 & is_arx=0 & is_ind=1 & ind  {}
:SUBT dma is  op_8_15=0b01100111 & is_ind=0 & dma  {}

# TBLR - Table read
#-------------------
# 1010 0110 IAAA AAAA -  direct or indirect
:TBLR ind, arx_0_2 is  op_8_15=0b10100110 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:TBLR ind is  op_8_15=0b10100110 & is_arx=0 & is_ind=1 & ind  {}
:TBLR dma is  op_8_15=0b10100110 & is_ind=0 & dma  {}

# TBLW - Table write
#--------------------
# 1010 0111 IAAA AAAA -  direct or indirect
:TBLW ind, arx_0_2 is  op_8_15=0b10100111 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:TBLW ind is  op_8_15=0b10100111 & is_arx=0 & is_ind=1 & ind  {}
:TBLW dma is  op_8_15=0b10100111 & is_ind=0 & dma  {}

# TRAP - Software interrupt
#---------------------------
# 1011 1110 0101 0001 -  
:TRAP  is  op_0_15=0b1011111001010001  {}

# XOR - Exclusive OR ACC
#------------------------
# 0110 1100 IAAA AAAA -  with data value, direct or indirect
:XOR ind, arx_0_2 is  op_8_15=0b01101100 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:XOR ind is  op_8_15=0b01101100 & is_arx=0 & is_ind=1 & ind  {}
:XOR dma is  op_8_15=0b01101100 & is_ind=0 & dma  {}
# 1011 1111 1101 SHFT -  with shift of 0 to 15, long immediate
:XOR #long_imm is  op_4_15=0b101111111101 & shft_0_3=0 ; long_imm {}
:XOR #long_imm, shft_0_3 is  op_4_15=0b101111111101 & shft_0_3 ; long_imm {}
# 1011 1110 1000 0011 -  with shift of 16, long immediate
:XOR #long_imm, "16" is  op_0_15=0b1011111010000011 ; long_imm {}

# ZALR - Zero low ACC and load high ACC with rounding
#-----------------------------------------------------
# 0110 1000 IAAA AAAA -  direct or indirect
:ZALR ind, arx_0_2 is  op_8_15=0b01101000 & is_arx=1 & is_ind=1 & ind & arx_0_2  {}
:ZALR ind is  op_8_15=0b01101000 & is_arx=0 & is_ind=1 & ind  {}
:ZALR dma is  op_8_15=0b01101000 & is_ind=0 & dma  {}
