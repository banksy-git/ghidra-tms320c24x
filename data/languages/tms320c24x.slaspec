# tms320c24x processor spec 
#   >> see docs/languages/sleigh.htm or sleigh.pdf for Sleigh syntax
# Other language modules (see Ghidra/Processors) may provide better examples
# when creating a new language module.

define endian=little;
define alignment=2;

define space code type=ram_space size=2 wordsize=2;
define space ram type=ram_space size=2 wordsize=2 default;
define space io type=ram_space size=2 wordsize=2;
define space hwstack type=ram_space wordsize=2 size=2;
define space register type=register_space wordsize=2 size=1;

define register offset=0x00 size=2 [ PC ];
define register offset=0x02 size=4 [ ACC PREG ];
define register offset=0x10 size=2 [ TREG AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 ST0 ST1 SP ];

define register offset=0x100 size=4 contextreg;
define context contextreg
  ctx_dp=(0, 9)
  ctx_arp=(10, 12)
;

# ST0 bits
@define DP	  "ST0[0,9]"  # Data page pointer
@define INTM  "ST0[9,1]"  # Interrupt mode bit
@define OVM   "ST0[11,1]" # Overflow mode bit
@define OV    "ST0[12,1]" # Overflow flag bit
@define ARP   "ST0[13,3]" # Auxiliary register pointer

# ST1 bits
@define PM	"ST1[0,2]"    # Product shift mode
@define XF	"ST1[4,1]"    # XF pin status bit
@define C  	"ST1[9,1]"    # Carry bit
@define SXM	"ST1[10,1]"   # Sign-extension mode bit
@define TC 	"ST1[11,1]"   # Test/control flag bit
@define CNF	"ST1[12,1]"   # On-chip DARAM configuration bit
@define ARB	"ST1[13,3]"   # Auxiliary register pointer buffer

macro push(val) {
	*[hwstack]:1 SP = val;
	SP = SP + 1;
}

macro pop(rval) {	
#	CheckStackUnderflow();
  SP = SP - 1;
	rval = *[hwstack]:1 SP;
}

macro update_arx(new_arx) 
{
}

define token inst(16)
  # OPCode prefixes
  op_0_15 = (0, 15)
  op_1_15 = (1, 15)
  op_2_15 = (2, 15)
  op_3_15 = (3, 15)
  op_4_15 = (4, 15)
  op_5_15 = (5, 15)
  op_6_15 = (6, 15)
  op_7_15 = (7, 15)
  op_8_15 = (8, 15)
  op_9_15 = (9, 15)
  op_10_15 = (10, 15)
  op_11_15 = (11, 15)
  op_12_15 = (12, 15)
  op_13_15 = (13, 15)
  op_14_15 = (14, 15)

  shft_8_11 = (8, 11)
  shf_8_10 = (8, 10)
  shft_0_3 = (0, 3)
  short_imm_0_7 = (0, 7)

  tpzlvczlvc_0_9 = (0, 9)
  bitx_8_11 = (8, 11)
  cm_0_1 = (0, 1)
  pm_0_1 = (0, 1)
  ntr_0_3 = (0, 3)
  addr9_0_8 = (0, 8)
  addr13_0_12 = (0, 12)
  arx2_8_10 = (8, 10)

  # Direct / Indirect 
  dma_0_6 = (0, 6)
  arx_0_2 = (0, 2)
  arx2_0_2 = (0, 2)
  is_arx = (3, 3)
  aru_4_6 = (4, 6)
  is_ind = (7, 7)
;

define token data16 (16)
   imm16 = (0,15)
;

pma: imm16 is imm16	{ 
  export *[code]:2 imm16; 
}

long_imm: imm16 is imm16	{ 
  local var:2 = imm16;
  export var; 
}

dma: addr is ctx_dp & dma_0_6 [addr = (ctx_dp<<7) | dma_0_6; ] {
  export *[ram]:2 addr;
}

attach variables [ arx_0_2 arx2_0_2 aru_4_6 arx2_8_10 ctx_arp ] [ AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 ];

ind: "*"        is aru_4_6=0b000 & aru_4_6 {
  local addr:2 = aru_4_6;
  export *[ram]:2 addr;
}
ind: "*-"       is aru_4_6=0b001 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr - 1;
  export *[ram]:2 addr;
}
ind: "*+"       is aru_4_6=0b010 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr + 1;
  export *[ram]:2 addr;
}
ind: "reserved" is aru_4_6=0b011 & aru_4_6 { 
  local addr:2 = aru_4_6;
  export *[ram]:2 addr;
}
ind: "*BR0-"    is aru_4_6=0b100 & aru_4_6 { 
  local addr:2 = aru_4_6;
  aru_4_6 = addr - AR0; # TODO: Fix for reverse carry
  export *[ram]:2 addr;
}
ind: "*0-"      is aru_4_6=0b101 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr - AR0;
  export *[ram]:2 addr;
}
ind: "*0+"      is aru_4_6=0b110 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr + AR0;
  export *[ram]:2 addr;
}
ind: "*BR0+"    is aru_4_6=0b111 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr + AR0; # TODO: Fix for reverse carry
  export *[ram]:2 addr;
}

######################################
# Instruction semantics
######################################

# ADD - Add to ACC
#------------------
macro instr_add_internal(val) {
  ACC = ACC + val;
}
macro instr_add(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_add_internal(_val);
}
macro instr_add_shift(val, shift) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_add_internal(_val);
}

# ADDC - Add to ACC with carry
#------------------------------
macro instr_addc(val) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  ACC = ACC + _val;
}

# ADDS - Add to low ACC with sign-extension suppressed
#------------------------------------------------------
macro instr_adds(val) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  ACC = ACC + _val;
}

# ADDT - Add to ACC with shift (0 to 15) specified by TREG
#----------------------------------------------------------
macro instr_addt(val) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << TREG;
  ACC = ACC + _val;
}

# AND - AND ACC
#---------------
macro instr_and_internal(val) {
  ACC = ACC & val;
}
macro instr_and(val) {	
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  instr_and_internal(_val);
}
macro instr_and_shift(val, shift) {
  local _val16:2 = val;		
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_and_internal(_val);
}

# BIT - Test bit
#----------------
macro instr_bit(val, bitcode) {
  local _val:2 = val;
  $(TC) = (_val & (1<<(15-bitcode))) != 0;
}

# BITT - Test bit specified by TREG
#-----------------------------------
macro instr_bitt(val) {
  local _val:2 = val;
  $(TC) = (_val & (1<<(15-TREG[0,4]))) != 0;
}

# LACC - Load ACC
#-----------------
macro instr_lacc_internal(val) {
  ACC = val;
}
macro instr_lacc(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_lacc_internal(_val);
}
macro instr_lacc_shift(val, shift) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_lacc_internal(_val);
}

# LACL - Load low word of ACC
#-----------------------------
macro instr_lacl(val) {	
  local _val16:2 = val;
  ACC[0,16] = _val16;
}

# LACT - Load ACC with shift (0 to 15) specified by TREG
#--------------------------------------------------------
macro instr_lact(val) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << TREG;
  ACC = _val;
}

# LAR - Load specified AR
#-------------------------
macro instr_lar(register, val) {
  local _val16:2 = val;	
  local _val:2 = zext(_val16);
  register = _val;
}

# LDP - Load data page pointer
#------------------------------
macro instr_ldp(val) {
  local _val16:2 = val;	
  local _val:2 = zext(_val16);
  $(DP) = _val;
}

# LPH - Load high PREG
#----------------------
macro instr_lph(val) {
  local _val16:2 = val;	
  local _val:2 = zext(_val16);
  PREG[16,16]= _val;
}

# LST - Load status register
#----------------------------
macro instr_lst0(val) {
  local _val16:2 = val;
  ST0[0,9] = _val16[0,9];
  ST0[10,1] = 1;
  ST0[11,5] = _val16[11,5];
}
macro instr_lst1(val) {
  local _val16:2 = val;
  $(ARP) = _val16[13,3];
  $(ARB) = _val16[13,3];
  $(CNF) = _val16[12,1];
  $(TC) = _val16[11,1];
  $(SXM) = _val16[10,1];
  $(C) = _val16[9,1];
  $(XF) = _val16[4,1];
  $(PM) = _val16[0,2];
  ST1[2,2] = 0b11;
  ST1[5,4] = 0b1111;
}

# LT - Load TREG
#----------------
macro instr_lt(val) {
  local _val16:2 = val;	
  local _val:2 = zext(_val16);
  TREG = _val;
}

# OR - OR ACC
#-------------
macro instr_or_internal(val) {
  ACC = ACC | val;
}
macro instr_or(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_or_internal(_val);
}
macro instr_or_shift(val, shift) {
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_or_internal(_val);
}

# POPD - Pop top of stack to data memory
#----------------------------------------
macro instr_popd(memloc) {	
  local val:2 = 0;
  pop(val);
  memloc = val;
}

# PSHD - Push data memory value on stack
#----------------------------------------
macro instr_pshd(val) {
  local _val:2 = val;
  push(_val);
}

# SACH - Store high ACC
#-----------------------
macro instr_sach(memloc, shift_) {
  local shift:1 = shift_;
  local val:4 = zext(ACC[16, 16]) << shift;
  memloc = val[0, 16];
}

# SACL - Store low ACC
#----------------------
macro instr_sacl(memloc, shift_) {
  local shift:1 = shift_;
  local val:4 = zext(ACC[0, 16]) << shift;
  memloc = val[0, 16];
}

# SPH - Store high PREG
#-----------------------
macro instr_sph(memloc) {
  memloc = PREG[16, 16];
}

# SPL - Store low PREG
#----------------------
macro instr_spl(memloc) {
  memloc = PREG[0, 16];
}

# SPLK - Store long immediate to data memory location
#-----------------------------------------------------
macro instr_splk(memloc, k) {
  memloc = k;
}

# SST - Store status register
#-----------------------------
macro instr_sst0(memloc) {
  memloc = ST0;
}
macro instr_sst1(memloc) {
  memloc = ST1;
}

# SUB - Subtract from ACC
#-------------------------
macro instr_sub_internal(val) {
  ACC = ACC - val;
}
macro instr_sub(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_sub_internal(_val);
}
macro instr_sub_shift(val, shift) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_sub_internal(_val);
}

# SUBB - Subtract from ACC with borrow
#--------------------------------------
macro instr_subb(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  ACC = ACC - _val;
}

# SUBC - Conditional subtract
#-----------------------------
macro instr_subc(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  ACC = ACC - _val;
}

# SUBS - Subtract from ACC with sign-extension suppressed
#---------------------------------------------------------
macro instr_subs(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  ACC = ACC - _val;
}

# SUBT - Subtract from ACC with shift (0 to 15) specified by TREG
#-----------------------------------------------------------------
macro instr_subt(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  ACC = ACC - _val;
}

# TBLR - Table read
#-------------------
macro instr_tblr(val) {	
  local prog_addr:2 = ACC[0,16];
  local prog_val:2 = *[code]:2 prog_addr;
  val = prog_val;
}

# TBLW - Table write
#--------------------
macro instr_tblw(val) {	
  local prog_addr:2 = ACC[0,16];
  *[code]:2 prog_addr = *val;
}

# XOR - Exclusive OR ACC
#------------------------
macro instr_xor_internal(val) {
  ACC = ACC ^ val;
}
macro instr_xor(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_xor_internal(_val);
}
macro instr_xor_shift(val, shift) {
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_xor_internal(_val);
}


@include "tms320c24x_opcodes.slinc"