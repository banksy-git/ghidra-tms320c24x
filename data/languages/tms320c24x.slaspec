# tms320c24x processor spec 
#   >> see docs/languages/sleigh.htm or sleigh.pdf for Sleigh syntax
# Other language modules (see Ghidra/Processors) may provide better examples
# when creating a new language module.

define endian=little;
define alignment=2;

define space code type=ram_space size=2 wordsize=2 default;
define space ram type=ram_space size=2 wordsize=2;
define space io type=ram_space size=2 wordsize=2;
define space hwstack type=ram_space wordsize=2 size=2;
define space register type=register_space wordsize=2 size=1;

define register offset=0x00 size=2 [ PC ];
define register offset=0x02 size=4 [ ACC PREG ];
define register offset=0x02 size=2 [ ACCL ACCH PREGL PREGH ];
define register offset=0x10 size=2 [ TREG AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 ST0 ST1 SP DP ];

define register offset=0x100 size=4 contextreg;
define context contextreg
  ctx_dp=(0, 8)
  ctx_arp=(10, 12)
;

# ST0 bits
@define DP	  "ST0[0,9]"  # Data page pointer
@define INTM  "ST0[9,1]"  # Interrupt mode bit
@define OVM   "ST0[11,1]" # Overflow mode bit
@define OV    "ST0[12,1]" # Overflow flag bit
@define ARP   "ST0[13,3]" # Auxiliary register pointer

# ST1 bits
@define PM	"ST1[0,2]"    # Product shift mode
@define XF	"ST1[4,1]"    # XF pin status bit
@define C  	"ST1[9,1]"    # Carry bit
@define SXM	"ST1[10,1]"   # Sign-extension mode bit
@define TC 	"ST1[11,1]"   # Test/control flag bit
@define CNF	"ST1[12,1]"   # On-chip DARAM configuration bit
@define ARB	"ST1[13,3]"   # Auxiliary register pointer buffer

macro push(val) {
	*[hwstack]:1 SP = val;
	SP = SP + 1;
}

macro pop(rval) {	
#	CheckStackUnderflow();
  SP = SP - 1;
	rval = *[hwstack]:1 SP;
}

macro update_arx(new_arx) 
{
}

define token inst(16)
  # OPCode prefixes
  op_0_15 = (0, 15)
  op_1_15 = (1, 15)
  op_2_15 = (2, 15)
  op_3_15 = (3, 15)
  op_4_15 = (4, 15)
  op_5_15 = (5, 15)
  op_6_15 = (6, 15)
  op_7_15 = (7, 15)
  op_8_15 = (8, 15)
  op_9_15 = (9, 15)
  op_10_15 = (10, 15)
  op_11_15 = (11, 15)
  op_12_15 = (12, 15)
  op_13_15 = (13, 15)
  op_14_15 = (14, 15)

  shft_8_11 = (8, 11)
  shf_8_10 = (8, 10)
  shft_0_3 = (0, 3)
  short_imm_0_7 = (0, 7)

  zl_tp = (8, 9)
  zl_result = (6, 7)
  zl_test = (2, 3)
  zl_testc_result = (4,4)
  zl_testc = (0,0)
  zl_testv_result = (5,5)
  zl_testv = (1,1)

  tpzlvczlvc_0_9 = (0, 9)
  bitx_8_11 = (8, 11)
  cm_0_1 = (0, 1)
  pm_0_1 = (0, 1)
  ntr_0_3 = (0, 3)
  addr9_0_8 = (0, 8)
  addr13_0_12 = (0, 12)
  arx2_8_10 = (8, 10)

  # Direct / Indirect 
  dma_0_6 = (0, 6)
  arx_0_2 = (0, 2)
  arx2_0_2 = (0, 2)
  is_arx = (3, 3)
  aru_4_6 = (4, 6)
  is_ind = (7, 7)
;

define token data16 (16)
   imm16 = (0,15)
;

pma: imm16 is imm16	{ 
  export *[code]:2 imm16; 
}

long_imm: imm16 is imm16	{ 
  local val:2 = imm16;
  export val;
}

dma: dma_0_6 is dma_0_6 {
  local addr:2 = (DP<<7) | dma_0_6;
  export *[ram]:2 addr;
}

attach variables [ arx2_0_2 aru_4_6 arx2_8_10 ctx_arp ] [ AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 ];

arx_sel: "AR0" is arx_0_2=0 { $(ARP) = 0; export 0:1; }
arx_sel: "AR1" is arx_0_2=1 { $(ARP) = 1; export 1:1; }
arx_sel: "AR2" is arx_0_2=2 { $(ARP) = 2; export 2:1; }
arx_sel: "AR3" is arx_0_2=3 { $(ARP) = 3; export 3:1; }
arx_sel: "AR4" is arx_0_2=4 { $(ARP) = 4; export 4:1; }
arx_sel: "AR5" is arx_0_2=5 { $(ARP) = 5; export 5:1; }
arx_sel: "AR6" is arx_0_2=6 { $(ARP) = 6; export 6:1; }
arx_sel: "AR7" is arx_0_2=7 { $(ARP) = 7; export 7:1; }

ind: "*"        is aru_4_6=0b000 & aru_4_6 {
  local addr:2 = aru_4_6;
  export *[ram]:2 addr;
}
ind: "*-"       is aru_4_6=0b001 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr - 1;
  export *[ram]:2 addr;
}
ind: "*+"       is aru_4_6=0b010 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr + 1;
  export *[ram]:2 addr;
}
ind: "reserved" is aru_4_6=0b011 & aru_4_6 { 
  local addr:2 = aru_4_6;
  export *[ram]:2 addr;
}
ind: "*BR0-"    is aru_4_6=0b100 & aru_4_6 { 
  local addr:2 = aru_4_6;
  aru_4_6 = addr - AR0; # TODO: Fix for reverse carry
  export *[ram]:2 addr;
}
ind: "*0-"      is aru_4_6=0b101 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr - AR0;
  export *[ram]:2 addr;
}
ind: "*0+"      is aru_4_6=0b110 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr + AR0;
  export *[ram]:2 addr;
}
ind: "*BR0+"    is aru_4_6=0b111 & aru_4_6 {
  local addr:2 = aru_4_6;
  aru_4_6 = addr + AR0; # TODO: Fix for reverse carry
  export *[ram]:2 addr;
}

condA: "EQ"  is zl_test=0b10 & zl_result=0b10 { local x:1 = ACC == 0; export x; }
condA: "NEQ" is zl_test=0b10 & zl_result=0b00 { local x:1 = ACC != 0; export x; }
condA: "LT" is  zl_test=0b01 & zl_result=0b01 { local x:1 = ACC s< 0; export x; }
condA: "GT" is  zl_test=0b01 & zl_result=0b00 { local x:1 = ACC s> 0; export x; }
condA: "LEQ" is zl_test=0b11 & zl_result=0b11 { local x:1 = ACC s<= 0; export x; }
condA: "GEQ" is zl_test=0b11 & zl_result=0b10 { local x:1 = ACC s>= 0; export x; }
condA: "" is    zl_test=0b00 { local x:1 = 1; export x; }

condC: "C"  is zl_testc=1 & zl_testc_result=1 { local x:1 = $(C) == 1; export x; }
condC: "NC" is zl_testc=1 & zl_testc_result=0 { local x:1 = $(C) == 0; export x; }
condC: ""   is zl_testc=0 { local x:1 = 1; export x; }

condV: "OV"  is zl_testv=1 & zl_testv_result=1 { local x:1 = $(OV) == 1; export x; }
condV: "NOV" is zl_testv=1 & zl_testv_result=0 { local x:1 = $(OV) == 0; export x; }
condV: ""    is zl_testv=0 { local x:1 = 1; export x; }

condT: "BIO" is zl_tp=0 { local x:1 = 1; export x; }
condT: "TC"  is zl_tp=1 { local x:1 = $(TC)==1; export x; }
condT: "NTC" is zl_tp=2 { local x:1 = $(TC)==0; export x; }
condT: ""    is zl_tp=3 { local x:1 = 1; export x; }

cond: condA condC condV condT is condA & condC & condV & condT {
  local result:1 = condA & condC & condV & condT;
  export result;
}

macro get_ar(dst) {
  if ($(ARP) != 0) goto <b>; dst = AR0; goto <done>;
  <b> if ($(ARP) != 1) goto <c>; dst = AR1; goto <done>;
  <c> if ($(ARP) != 2) goto <d>; dst = AR2; goto <done>;
  <d> if ($(ARP) != 3) goto <e>; dst = AR3; goto <done>;
  <e> if ($(ARP) != 4) goto <ff>; dst = AR4; goto <done>;
  <ff> if ($(ARP) != 5) goto <gg>; dst = AR5; goto <done>;
  <gg> if ($(ARP) != 6) goto <h>; dst = AR6; goto <done>;
  <h> if ($(ARP) != 7) goto <done>; dst = AR7;
  <done>
}

cmpr_op: "00 ;AR=AR0" is cm_0_1=0 { local x:2 = 0; get_ar(x); $(TC) = x==AR0; }
cmpr_op: "01 ;AR<AR0" is cm_0_1=1 { local x:2 = 0; get_ar(x); $(TC) = x<AR0;}
cmpr_op: "10 ;AR>AR0" is cm_0_1=2 { local x:2 = 0; get_ar(x); $(TC) = x>AR0;}
cmpr_op: "11 ;AR<>AR0" is cm_0_1=3 { local x:2 = 0; get_ar(x); $(TC) = x!=AR0;}


######################################
# Instruction semantics
######################################

# ADD - Add to ACC
#------------------
macro instr_add_internal(val) {
  ACC = ACC + val;
}
macro instr_add(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_add_internal(_val);
}
macro instr_add_shift(val, shift) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_add_internal(_val);
}

# ADDC - Add to ACC with carry
#------------------------------
macro instr_addc(val) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  ACC = ACC + _val;
}

# ADDS - Add to low ACC with sign-extension suppressed
#------------------------------------------------------
macro instr_adds(val) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  ACC = ACC + _val;
}

# ADDT - Add to ACC with shift (0 to 15) specified by TREG
#----------------------------------------------------------
macro instr_addt(val) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << TREG;
  ACC = ACC + _val;
}

# AND - AND ACC
#---------------
macro instr_and_internal(val) {
  ACC = ACC & val;
}
macro instr_and(val) {	
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  instr_and_internal(_val);
}
macro instr_and_shift(val, shift) {
  local _val16:2 = val;		
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_and_internal(_val);
}

# BIT - Test bit
#----------------
macro instr_bit(val, bitcode) {
  local _val:2 = val;
  $(TC) = (_val & (1<<(15-bitcode))) != 0;
}

# BITT - Test bit specified by TREG
#-----------------------------------
macro instr_bitt(val) {
  local _val:2 = val;
  $(TC) = (_val & (1<<(15-TREG[0,4]))) != 0;
}

# LACC - Load ACC
#-----------------
macro instr_lacc_internal(val) {
  ACC = val;
}
macro instr_lacc(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_lacc_internal(_val);
}
macro instr_lacc_shift(val, shift) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_lacc_internal(_val);
}

# LACL - Load low word of ACC
#-----------------------------
macro instr_lacl(val) {	
  local _val16:2 = val;
  ACCL = _val16;
}

# LACT - Load ACC with shift (0 to 15) specified by TREG
#--------------------------------------------------------
macro instr_lact(val) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << TREG;
  ACC = _val;
}

# LAR - Load specified AR
#-------------------------
macro instr_lar(register, val) {
  local _val16:2 = val;	
  local _val:2 = zext(_val16);
  register = _val;
}

# LDP - Load data page pointer
#------------------------------
macro instr_ldp(val, ctx_dp) {
  local _val16:2 = val;
  DP = val;
  $(DP) = _val16[0,9];
  ctx_dp = 0;
}

# LPH - Load high PREG
#----------------------
macro instr_lph(val) {
  local _val16:2 = val;	
  local _val:2 = zext(_val16);
  PREGH = _val;
}

# LST - Load status register
#----------------------------
macro instr_lst0(val) {
  local _val16:2 = val;
  ST0[0,9] = _val16[0,9];
  ST0[10,1] = 1;
  ST0[11,5] = _val16[11,5];
}
macro instr_lst1(val) {
  local _val16:2 = val;
  $(ARP) = _val16[13,3];
  $(ARB) = _val16[13,3];
  $(CNF) = _val16[12,1];
  $(TC) = _val16[11,1];
  $(SXM) = _val16[10,1];
  $(C) = _val16[9,1];
  $(XF) = _val16[4,1];
  $(PM) = _val16[0,2];
  ST1[2,2] = 0b11;
  ST1[5,4] = 0b1111;
}

# LT - Load TREG
#----------------
macro instr_lt(val) {
  local _val16:2 = val;	
  local _val:2 = zext(_val16);
  TREG = _val;
}

# OR - OR ACC
#-------------
macro instr_or_internal(val) {
  ACC = ACC | val;
}
macro instr_or(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_or_internal(_val);
}
macro instr_or_shift(val, shift) {
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_or_internal(_val);
}

# POPD - Pop top of stack to data memory
#----------------------------------------
macro instr_popd(memloc) {	
  local val:2 = 0;
  pop(val);
  memloc = val;
}

# PSHD - Push data memory value on stack
#----------------------------------------
macro instr_pshd(val) {
  local _val:2 = val;
  push(_val);
}

# SACH - Store high ACC
#-----------------------
macro instr_sach(memloc, shift_) {
  local shift:1 = shift_;
  local val:2 = zext(ACCH) << shift;
  memloc = val;
}

# SACL - Store low ACC
#----------------------
macro instr_sacl(memloc, shift_) {
  local shift:1 = shift_;
  local val:2 = zext(ACCL) << shift;
  memloc = val;
}

# SPH - Store high PREG
#-----------------------
macro instr_sph(memloc) {
  memloc = PREGH;
}

# SPL - Store low PREG
#----------------------
macro instr_spl(memloc) {
  memloc = PREGL;
}

# SPLK - Store long immediate to data memory location
#-----------------------------------------------------
macro instr_splk(memloc, k) {
  memloc = k;
}

# SST - Store status register
#-----------------------------
macro instr_sst0(memloc) {
  memloc = ST0;
}
macro instr_sst1(memloc) {
  memloc = ST1;
}

# SUB - Subtract from ACC
#-------------------------
macro instr_sub_internal(val) {
  ACC = ACC - val;
}
macro instr_sub(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_sub_internal(_val);
}
macro instr_sub_shift(val, shift) {
  local _val16:2 = val;	
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_sub_internal(_val);
}

# SUBB - Subtract from ACC with borrow
#--------------------------------------
macro instr_subb(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  ACC = ACC - _val;
}

# SUBC - Conditional subtract
#-----------------------------
macro instr_subc(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  ACC = ACC - _val;
}

# SUBS - Subtract from ACC with sign-extension suppressed
#---------------------------------------------------------
macro instr_subs(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  ACC = ACC - _val;
}

# SUBT - Subtract from ACC with shift (0 to 15) specified by TREG
#-----------------------------------------------------------------
macro instr_subt(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  ACC = ACC - _val;
}

# TBLR - Table read
#-------------------
macro instr_tblr(val) {	
  local prog_addr:2 = ACC[0,16];
  local prog_val:2 = *[code]:2 prog_addr;
  val = prog_val;
}

# TBLW - Table write
#--------------------
macro instr_tblw(val) {	
  local prog_addr:2 = ACC[0,16];
  *[code]:2 prog_addr = *val;
}

# XOR - Exclusive OR ACC
#------------------------
macro instr_xor_internal(val) {
  ACC = ACC ^ val;
}
macro instr_xor(val) {	
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  instr_xor_internal(_val);
}
macro instr_xor_shift(val, shift) {
  local _val16:2 = val;
  local _val:4 = zext(_val16);
  _val = _val << shift;
  instr_xor_internal(_val);
}


@include "tms320c24x_opcodes.slinc"